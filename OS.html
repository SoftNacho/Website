<!DOCTYPE HTML>

<html>
	<head>
		<title>Lisa Gentil - OS</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="assets/css/main.css" />
		<!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
		<!--[if lte IE 9]><link rel="stylesheet" href="assets/css/ie9.css" /><![endif]-->
	</head>
	<body class="landing">

		<!-- Header -->
			<header id="header" class="alt ">
				<!--
                <h1><a href="index.html">Drift <span>by Pixelarity</span></a></h1>
				-->
                <nav id="nav">
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="index.html" class="icon fa-angle-down">About Me</a></li>
                        <li>
                            <a href="index.html" class="icon fa-angle-down">Projects</a>
							<ul>
                                <li><a href="OS.html">Operating System NachOS</a></li>
                                <li><a 
                                href="LC3b.html">LC-3b Processor
                                </a></li>
                                <li><a href="2048.html">2048</a></li>
                                <li><a href="TicTacToe.html">Tic Tac Toe</a></li>
                                <li><a href="Adventure.html">Adventure</a></li>
                                <li><a href="Sudoku.html">Sudoku</a></li>
                                <li><a href="PhotoEditor.html">Photo Editor</a></li>
                                <li><a href="FlappyBird.html">Flappy Bird</a></li>
                                <li><a href="Calculator.html">Calculator</a></li>
                            </ul>
                            <li><a href="Resume.html">Résumé</a></li>
					</ul>
				</nav>
			</header>

		<!-- Banner -->
			<section id="bannerOS">
				<div class="inner">
					<h2>NachOS</h2>
                    <ul class="actions">
						<li><a href="index.html" class="button big scrolly">BACK TO MAIN MENU</a></li>
					</ul>
				</div>
			</section>
            
        <!--Presentation of projects-->
        <section id="presentation">
            <div align="center">
                <h3>Presentation of Project</h3>
                <p>The class was an introduction to Operating Systems engineering and our biggest project was to create an OS from the ground up using C for the main functions and x86 Assembly for macros.</p>
            </div>
        </section>
        
        
        <!-- Contributions -->
        <section id="contributions">
            <div align="center"><h3>Our Contributions</h3></div>
            <div align="left">
                <p>The project was split over 10 weeks into different tasks:<li>setting up IDT, RTC and paging <li>Creating files system <li>Handling system calls, interrupts, exceptions <li>Keyboard handling and Key Commands <li>Three Terminals with shells <li>Scheduler: setting up context switch</li></p>
            </div>
        </section>
        
        <!-- Boot log -->
        <section id="bug">
            <div align="center"><h3>Our Bug Log</h3></div>
            <div align="left">
                <p>ECE 391 - NachOS Bug Log
<br>Jason Daniel, Anthony Zhang, Lisa Gentil, Ada Hui

<br>Task 1
	<br>- We did not consider interrupts from the PIT in setting up the IDT, so setting the RTC settings to enable this interrupt
	would cause a page fault
	<br>- trap gates and interrupt gates must be distinct bit vectors in the IDT table. Bit vectors were ommitted and so interrupts did
	not work properly<br>
                    
<br>Task 2
	<br>- Issue where we didn't have a handler tied to INT 8, rtc read didn't work until this is set up
	<br>- Some issues with how we read the page directory; tests didn't actually test correct functions implemented
	<br>- When printint size of the directory, it would show a number other than 0<br>
                    
<br>Task 3
	<br>- PCB size needed to be updated frequently, if we failed to do so a page fault would occur
	<br>- IRET context set up incorrectly, page faulted after IRET executed once system calls were complete
	<br>- Issue where Halt would jump back into execute but execute wouldn't return correctly<br>
                    
<br>Task 4
	<br>- Rtc flag was set in the incorrect handler, supposed to be set in INT 8 instead of INT 0
	<br>- Error in checking in system calls was insufficient; additional checks added to ensure correct behavior
	<br>- FOPS table was placed incorrectly, should be static global and not local variables
	<br>- FOPS table was incorrectly made as regular void pointers, not as function pointers to allow for 1 line executution of system calls before error checking
	<br>- Special Characters (!@#$%^&*()) implemented; not having these would result in incomplete grep functionality<br>

<br>task 5
	<br>- All references to active terminal changed to terminal of current process bein g run for all system calls (exception of keyboard handler and drawing to vga); this fixed our issue with video memory being drawn to the incorrect location
	<br>- In setting up the context switch, needed to emulate as if system_execute was called by setting up stack frame exactly with appropriate tss and esp/ebp values; fixed issue where system would triple fault after context switch
	<br>- Strange behavior noted when running three concurrent instances of fish; once one finished, the other two would slow down considerably
	<br>- Incorrect handler implementation for both RTC and PIT (their functions had been swapped by accident)</p>
            </div>
        </section>
        
             <br> 
        <!--Buttons-->
        <div align="center">
            
            <a href="#boot.S" class="buttonInPage"> boot.S </a>
            <a href="#devices.c"class="buttonInPage"> devices.c </a>
            <a href="#devices.h"class="buttonInPage"> devices.h </a>
            <a href="#exceptions.c"class="buttonInPage"> exceptions.c </a>
            <a href="#exceptions.h"class="buttonInPage"> exceptions.h </a>
            <a href="#file_system.c"class="buttonInPage"> file_system.c </a>
            <a href="#file_system.h"class="buttonInPage"> file_system.h </a>
            <a href="#kernel.c"class="buttonInPage"> kernel.c </a>
            <a href="#i8259.c" class="buttonInPage"> i8259.c </a>
            <a href="#lib.c"class="buttonInPage"> lib.c </a>
            <a href="#lib.h"class="buttonInPage"> lib.h </a>
            <a href="#paging.c"class="buttonInPage"> paging.c </a>
            <a href="#paging.h"class="buttonInPage"> paging.h </a>
            <a href="#scheduler.c"class="buttonInPage"> scheduler.c </a>
            <a href="#scheduler.h"class="buttonInPage"> scheduler.h </a>
            <a href="#system_calls.c"class="buttonInPage"> system_calls.c </a>
            <a href="#system_calls.h"class="buttonInPage"> system_calls.h </a>
            <a href="#terminal.c"class="buttonInPage"> terminal.c </a>
            <a href="#terminal.h"class="buttonInPage"> terminal.h </a>
            <a href="#Makefile"class="buttonInPage"> Makefile </a>
        
        </div>   
            
        
        
        <!--boot.S-->
        <section>
            <hnew id="boot.S">boot.S</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic"># boot.S - start point for the kernel after GRUB gives us control</span>
<span style="font-style: italic"># vim:ts=4 noexpandtab</span>

<span style="font-style: italic">#define ASM     1</span>

<span style="font-style: italic">#include &quot;multiboot.h&quot;</span>
<span style="font-style: italic">#include &quot;x86_desc.h&quot;</span>

.text

	<span style="font-style: italic"># Multiboot header (required for GRUB to boot us)</span>
	.long MULTIBOOT_HEADER_MAGIC
	.long MULTIBOOT_HEADER_FLAGS
	.long -(MULTIBOOT_HEADER_MAGIC+MULTIBOOT_HEADER_FLAGS)

<span style="font-style: italic"># Entrypoint to the kernel</span>
.globl  start, _start

.align 4
start:
_start:
	<span style="font-style: italic"># Make sure interrupts are off</span>
	cli
	jmp     continue

continue:
	<span style="font-style: italic"># Load the GDT</span>
	lgdt gdt_desc
	lidt idt_desc_ptr

	<span style="font-style: italic"># Load CS with the new descriptor value</span>
	ljmp    $KERNEL_CS, $keep_going

keep_going:
	<span style="font-style: italic"># Set up ESP so we can have an initial stack</span>
	movl    $0x800000, %esp

	# Set up the rest of the segment selector registers
	movw    $KERNEL_DS, %cx
	movw    %cx, %ss
	movw    %cx, %ds
	movw    %cx, %es
	movw    %cx, %fs
	movw    %cx, %gs

	<span style="font-style: italic"># Push the parameters that entry() expects (see kernel.c):</span>
	<span style="font-style: italic"># eax = multiboot magic</span>
	<span style="font-style: italic"># ebx = address of multiboot info struct</span>
	pushl   %ebx
	pushl   %eax

	<span style="font-style: italic"># Jump to the C entrypoint to the kernel.</span>
	call    entry

	<span style="font-style: italic"># We&#39;ll never get back here, but we put in a hlt anyway.</span>
halt:
	hlt
	jmp     halt
</pre></div>
<p></p>
        </section>
        
        
        
        
        <!--devoces.c-->
        <section>
            <hnew id="devices.c">devices.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#include &quot;devices.h&quot;</span>
<span style="font-style: italic">#include &quot;scheduler.h&quot;</span>
<span style="font-style: italic">#define BACKSPACE_SCAN_CODE -1234</span>
<span style="font-style: italic">#define NUM_ASCII_CHARS 256</span>
<span style="font-style: italic">#define INIT_RTC_FREQ 2</span>
<span style="font-style: italic">#define RTC_RATE0 0xF</span>
<span style="font-style: italic">#define RTC_RATE1 0xE</span>
<span style="font-style: italic">#define RTC_RATE2 0xD</span>
<span style="font-style: italic">#define RTC_RATE3 0xC</span>
<span style="font-style: italic">#define RTC_RATE4 0xB</span>
<span style="font-style: italic">#define RTC_RATE5 0xA</span>
<span style="font-style: italic">#define RTC_RATE6 0x9</span>
<span style="font-style: italic">#define RTC_RATE7 0x8</span>
<span style="font-style: italic">#define RTC_RATE8 0x7</span>
<span style="font-style: italic">#define RTC_RATE9 0x6</span>
<span style="font-style: italic">#define NUM_RTC_RATES 10</span>
<span style="font-style: italic">#define MAX_FILE_IDX 16</span>

<span style="font-weight: bold">static</span> <span style="font-weight: bold">uint8_t</span> rtc_flag = 0; <span style="font-style: italic">// flag used by rtc handler and rtc read</span>
<span style="font-weight: bold">static</span> <span style="font-weight: bold">uint8_t</span> rtc_rate[NUM_RTC_RATES] = {RTC_RATE0, RTC_RATE1, RTC_RATE2, RTC_RATE3, RTC_RATE4, RTC_RATE5, RTC_RATE6, RTC_RATE7, RTC_RATE8, RTC_RATE9}; <span style="font-style: italic">// array of possible rate values</span>
<span style="font-weight: bold">static</span> <span style="font-weight: bold">uint8_t</span> rtc_disp_toggle = 0; <span style="font-style: italic">//toggle flag for the rtc</span>
<span style="font-weight: bold">static</span> <span style="font-weight: bold">uint32_t</span> file_idx = 0;
<span style="font-weight: bold">static</span> <span style="font-weight: bold">int</span> rtc_freq = INIT_RTC_FREQ;

<span style="font-weight: bold">uint8_t</span> ctrl_flag = 0, l_flag = 0, shift_flag = 0, caps_lock_flag = 0,	one_flag = 0, two_flag = 0, three_flag = 0, four_flag = 0, five_flag = 0, alt_flag = 0;


<span style="font-weight: bold">int</span> ascii_sc_LUT[NUM_ASCII_CHARS] = {-1, ESCAPE, <span style="font-style: italic">&#39;1&#39;</span>, <span style="font-style: italic">&#39;2&#39;</span>, <span style="font-style: italic">&#39;3&#39;</span>, <span style="font-style: italic">&#39;4&#39;</span>, <span style="font-style: italic">&#39;5&#39;</span>, <span style="font-style: italic">&#39;6&#39;</span>, <span style="font-style: italic">&#39;7&#39;</span>, <span style="font-style: italic">&#39;8&#39;</span>, <span style="font-style: italic">&#39;9&#39;</span>, <span style="font-style: italic">&#39;0&#39;</span>, <span style="font-style: italic">&#39;-&#39;</span>, <span style="font-style: italic">&#39;=&#39;</span>, BACKSPACE, TAB, <span style="font-style: italic">&#39;q&#39;</span>, <span style="font-style: italic">&#39;w&#39;</span>, <span style="font-style: italic">&#39;e&#39;</span>, <span style="font-style: italic">&#39;r&#39;</span>, <span style="font-style: italic">&#39;t&#39;</span>, <span style="font-style: italic">&#39;y&#39;</span>, <span style="font-style: italic">&#39;u&#39;</span>, <span style="font-style: italic">&#39;i&#39;</span>, <span style="font-style: italic">&#39;o&#39;</span>, <span style="font-style: italic">&#39;p&#39;</span>, <span style="font-style: italic">&#39;[&#39;</span>, <span style="font-style: italic">&#39;]&#39;</span>, <span style="font-style: italic">&#39;\n&#39;</span>, CTRL_DOWN, <span style="font-style: italic">&#39;a&#39;</span>, <span style="font-style: italic">&#39;s&#39;</span>,
						 		<span style="font-style: italic">&#39;d&#39;</span>, <span style="font-style: italic">&#39;f&#39;</span>, <span style="font-style: italic">&#39;g&#39;</span>, <span style="font-style: italic">&#39;h&#39;</span>, <span style="font-style: italic">&#39;j&#39;</span>, <span style="font-style: italic">&#39;k&#39;</span>, <span style="font-style: italic">&#39;l&#39;</span>, <span style="font-style: italic">&#39;;&#39;</span>, <span style="font-style: italic">&#39;\&#39;&#39;</span>, <span style="font-style: italic">&#39;`&#39;</span>, SHIFT_DOWN, <span style="font-style: italic">&#39;\\&#39;</span>, <span style="font-style: italic">&#39;z&#39;</span>, <span style="font-style: italic">&#39;x&#39;</span>, <span style="font-style: italic">&#39;c&#39;</span>, <span style="font-style: italic">&#39;v&#39;</span>, <span style="font-style: italic">&#39;b&#39;</span>, <span style="font-style: italic">&#39;n&#39;</span>, <span style="font-style: italic">&#39;m&#39;</span>, <span style="font-style: italic">&#39;,&#39;</span>, <span style="font-style: italic">&#39;.&#39;</span>, <span style="font-style: italic">&#39;/&#39;</span>, SHIFT_DOWN, <span style="font-style: italic">&#39;*&#39;</span>, ALT_DOWN, <span style="font-style: italic">&#39; &#39;</span>, CAPS_LOCK, F1, F2, F3, -1, -1,
						 				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, <span style="font-style: italic">&#39;-&#39;</span>, -1, -1, -1, <span style="font-style: italic">&#39;+&#39;</span>, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
						 						-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
						 								-1, -1, ONE_RELEASED, TWO_RELEASED, THREE_RELEASED, FOUR_RELEASED, FIVE_RELEASED, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, CTRL_RELEASED, -1, -1,
						 										-1, -1, -1, -1, -1, -1, L_RELEASED, -1, -1, -1, SHIFT_RELEASED, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, SHIFT_RELEASED, -1, ALT_RELEASED, -1, -1, -1, -1, -1, -1, -1,
						 												-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
						 														-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};						

<span style="font-weight: bold">int</span> ascii_special_char_LUT[NUM_ASCII_CHARS];

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function: 	init_RTC</span>
<span style="font-style: italic"> *Description:	initializes the Real Time Clock by setting the internal registers A to D to their desired initial values </span>
<span style="font-style: italic"> *Input:	none</span>
<span style="font-style: italic"> *Output:	none</span>
<span style="font-style: italic"> *Return value:	none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> init_RTC ()
{
		<span style="font-weight: bold">char</span> tmp_A, tmp_B;
		outb (RTC_REG_B_IDX, RTC_COMMAND);
        tmp_B = inb (RTC_DATA); <span style="font-style: italic">//capture the initial values of register B</span>
        tmp_B |= RTC_INIT_DIVIDER; <span style="font-style: italic">//toggle hi the initial divider frequency bit on the register</span>
        outb (tmp_B, RTC_DATA); <span style="font-style: italic">//send the changed register value to the RTC</span>

	    outb (RTC_REG_A_IDX, RTC_COMMAND); <span style="font-style: italic">//repeat process for register A </span>
        tmp_A = inb (RTC_DATA); 
        tmp_A = (RTC_PERIODIC_INT_ENABLE | tmp_A) | RTC_RATE ; <span style="font-style: italic">//toggle periodic interrupts hi</span>
        outb (tmp_A, RTC_DATA);

        enable_irq (RTC_IRQLINE); <span style="font-style: italic">//enable the irq line 0 on the PIC</span>

}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     init_keyboard</span>
<span style="font-style: italic"> *Description:  initializes the keyboard to the default keyboard settings</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> init_keyboard ()
{
		<span style="font-style: italic">//init_ascii_scancode_LUT();</span>
        outb (KEYBOARD_SET_DEFAULT, KEYBOARD_DATA); <span style="font-style: italic">//may want to disable key holding</span>
        enable_irq (KEYBOARD_IRQLINE); <span style="font-style: italic">//enable the irq line 1 on the PIC</span>
        ascii_special_char_LUT[<span style="font-style: italic">&#39;`&#39;</span>] = <span style="font-style: italic">&#39;~&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;1&#39;</span>] = <span style="font-style: italic">&#39;!&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;2&#39;</span>] = <span style="font-style: italic">&#39;@&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;3&#39;</span>] = <span style="font-style: italic">&#39;#&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;4&#39;</span>] = <span style="font-style: italic">&#39;$&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;5&#39;</span>] = <span style="font-style: italic">&#39;%&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;6&#39;</span>] = <span style="font-style: italic">&#39;^&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;7&#39;</span>] = <span style="font-style: italic">&#39;&amp;&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;8&#39;</span>] = <span style="font-style: italic">&#39;*&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;9&#39;</span>] = <span style="font-style: italic">&#39;(&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;0&#39;</span>] = <span style="font-style: italic">&#39;)&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;-&#39;</span>] = <span style="font-style: italic">&#39;_&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;=&#39;</span>] = <span style="font-style: italic">&#39;+&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;[&#39;</span>] = <span style="font-style: italic">&#39;{&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;]&#39;</span>] = <span style="font-style: italic">&#39;}&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;\\&#39;</span>] = <span style="font-style: italic">&#39;|&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;;&#39;</span>] = <span style="font-style: italic">&#39;:&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;\&#39;&#39;</span>] = <span style="font-style: italic">&#39;&quot;&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;,&#39;</span>] = <span style="font-style: italic">&#39;&lt;&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;.&#39;</span>] = <span style="font-style: italic">&#39;&gt;&#39;</span>;
        ascii_special_char_LUT[<span style="font-style: italic">&#39;/&#39;</span>] = <span style="font-style: italic">&#39;?&#39;</span>;
}


 <span style="font-style: italic">/*Function:	keyboard_handler_implementation   </span>
<span style="font-style: italic"> *Description:  Handles interrupts sent from the keyboard by reading the scan code and interpreting the code to generate the appropriate output on </span>
<span style="font-style: italic"> 				the screen. This includes handling capitalization, and also maps control + #&#39;s to test cases. The handler will call a function to update the VGA</span>
<span style="font-style: italic"> 				memory with the current keyboard buffer at the end of the function.</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> Side effects:  Video memory is updated with contents of the keyboard buffer. Keyboard buffer is also updated.</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>

<span style="font-weight: bold">void</span> keyboard_handler_implementation ()
{
        <span style="font-weight: bold">int</span> ascii_from_kb;
        <span style="font-weight: bold">int</span> scan_code; <span style="font-style: italic">//scan code received from keyboard</span>
		<span style="font-weight: bold">uint8_t</span> caps_offset;

        <span style="font-weight: bold">int</span> buf_length;
		
		send_eoi(SEND_EOI_1); 

        <span style="font-weight: bold">if</span> ((inb(KEYBOARD_STATUS) &amp; CHECK_CHAR) == CHECK_CHAR) { <span style="font-style: italic">//check if there are characters to be read in the buffer</span>
                scan_code = inb(KEYBOARD_DATA); <span style="font-style: italic">//get the scan scode from the keyboard</span>

                        ascii_from_kb = ascii_sc_LUT[scan_code]; <span style="font-style: italic">//assign ascii based on scan code</span>

                        <span style="font-weight: bold">if</span> (ascii_from_kb == BACKSPACE) { <span style="font-style: italic">//</span>
                        	<span style="font-weight: bold">if</span> (active_terminal-&gt;keyboard_buf_idx_tail == active_terminal-&gt;keyboard_buf_idx_head)
                        		<span style="font-weight: bold">return</span>;
                        	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (active_terminal-&gt;keyboard_buf_idx_tail == 0)
                        		active_terminal-&gt;keyboard_buf_idx_tail = KEYBOARD_BUF_SIZE - 1; <span style="font-style: italic">// move the tail pointer so that it wraps around</span>
                        	<span style="font-weight: bold">else</span>
                        		active_terminal-&gt;keyboard_buf_idx_tail = (active_terminal-&gt;keyboard_buf_idx_tail-1) % KEYBOARD_BUF_SIZE; <span style="font-style: italic">//update tail pointer </span>
                        	draw_terminal_to_vga (); <span style="font-style: italic">//draw current keyboard buffer</span>
                        }
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (active_terminal-&gt;keyboard_buf_idx_head == ((active_terminal-&gt;keyboard_buf_idx_tail + 1) % KEYBOARD_BUF_SIZE))
                    		<span style="font-weight: bold">return</span>; <span style="font-style: italic">// do nothing if circular buffer is full  </span>
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> ((ascii_from_kb == SHIFT_DOWN))
                        	shift_flag = 1; 
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == SHIFT_RELEASED)
                        	shift_flag = 0;     
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == CAPS_LOCK)
                        	caps_lock_flag ^= 0x01; <span style="font-style: italic">//toggle caps lock flag                        </span>
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == CTRL_DOWN)
                        	ctrl_flag = 1;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == CTRL_RELEASED)
                        	ctrl_flag = 0;                        
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == L_RELEASED) 
                        	l_flag = 0;                        
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == <span style="font-style: italic">&#39;l&#39;</span>)
                        	l_flag = 1;                    
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == <span style="font-style: italic">&#39;1&#39;</span>)
                        	one_flag = 1;
						<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == ONE_RELEASED)
                        	one_flag = 0; 
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == <span style="font-style: italic">&#39;2&#39;</span>)
                        	two_flag = 1;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == TWO_RELEASED)
                        	two_flag = 0;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == <span style="font-style: italic">&#39;3&#39;</span>)
                        	three_flag = 1;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == THREE_RELEASED)
                        	three_flag = 0;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == <span style="font-style: italic">&#39;4&#39;</span>)
                        	four_flag = 1;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == FOUR_RELEASED)
                        	four_flag = 0;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == <span style="font-style: italic">&#39;5&#39;</span>)
                        	five_flag = 1;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == FIVE_RELEASED)
                        	five_flag = 0;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == ALT_DOWN)
                            alt_flag = 1;
                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb == ALT_RELEASED)
                            alt_flag = 0;
                        
                        <span style="font-weight: bold">if</span> ((ctrl_flag &amp; l_flag)==0x01) { <span style="font-style: italic">//control + L should clear the terminal</span>
                        	<span style="font-style: italic">//keyboard_buf_idx_tail = keyboard_buf_idx_head; // we don&#39;t want this </span>
                        	clear_terminal();
                        	draw_terminal_to_vga();
                        	<span style="font-weight: bold">return</span>;
                        }

                        <span style="font-style: italic">// execute test 1</span>
                        <span style="font-weight: bold">if</span> ((ctrl_flag &amp; one_flag)==0x01) {
                            schedule ();
                        	<span style="font-style: italic">//list_files();</span>
                        	<span style="font-weight: bold">return</span>;
                        }

                        <span style="font-style: italic">// execute test 2</span>
                        <span style="font-weight: bold">if</span> ((ctrl_flag &amp; two_flag)==0x01) {
                        	read_file_by_name();
                        	<span style="font-weight: bold">return</span>;
                        }
                        <span style="font-style: italic">// execute test 3</span>
                        <span style="font-weight: bold">if</span> ((ctrl_flag &amp; three_flag)==0x01) {
                        	read_file_by_index(file_idx);
                        	file_idx++;
                        	<span style="font-weight: bold">if</span>(file_idx &gt;= MAX_FILE_IDX)
                        		file_idx = 0;
                        	<span style="font-weight: bold">return</span>;
                        }	

                        <span style="font-style: italic">// execute test 4</span>
                        <span style="font-weight: bold">if</span> ((ctrl_flag &amp; four_flag)==0x01) {
                        	rtc_test(rtc_freq);
                        	rtc_freq = rtc_freq &lt;&lt; 1;
                        	<span style="font-weight: bold">if</span>(rtc_freq &gt; MAX_FREQ) <span style="font-style: italic">//set frequency to wrap back around to minimum</span>
                        		rtc_freq = RTC_LOWEST_RATE;
                        	<span style="font-weight: bold">return</span>;
                        }

                        <span style="font-style: italic">// execute test 5</span>
                        <span style="font-weight: bold">if</span> ((ctrl_flag &amp; five_flag)==0x01) {
                        	rtc_test_end();
                        	<span style="font-weight: bold">return</span>;
                        }

                        <span style="font-style: italic">// switch to terminal 1</span>
                        <span style="font-weight: bold">if</span>((alt_flag &amp; (ascii_from_kb == F1)) == 0x1) { <span style="font-style: italic">// checks if ALT and F1 key is pressed</span>
                            switch_to_terminal (TERMINAL_ONE);
                        }

                        <span style="font-style: italic">// switch to terminal 2</span>
                        <span style="font-weight: bold">if</span>((alt_flag &amp; (ascii_from_kb == F2)) == 0x1) { <span style="font-style: italic">// checks if ALT and F2 key is pressed</span>
                            switch_to_terminal (TERMINAL_TWO);
                        }

                        <span style="font-style: italic">// switch to terminal 3</span>
                        <span style="font-weight: bold">if</span>((alt_flag &amp; (ascii_from_kb == F3)) == 0x1) { <span style="font-style: italic">// checks if ALT and F3 key is pressed</span>
                            switch_to_terminal (TERMINAL_THREE);
                        }


                        <span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (ascii_from_kb &gt;= 0) { <span style="font-style: italic">//negative value indicates an unmapped character</span>
							<span style="font-weight: bold">if</span> (active_terminal-&gt;keyboard_buf_idx_tail + 1 != active_terminal-&gt;keyboard_buf_idx_head){
								<span style="font-weight: bold">if</span>((shift_flag == 1 &amp;&amp; caps_lock_flag == 0) || (shift_flag == 0 &amp;&amp; caps_lock_flag == 1)) { 
									<span style="font-weight: bold">if</span> (ascii_from_kb &gt;= <span style="font-style: italic">&#39;a&#39;</span> &amp;&amp; ascii_from_kb &lt;= <span style="font-style: italic">&#39;z&#39;</span>) {<span style="font-style: italic">//only offset alphabetical characters</span>
										caps_offset = CAPITAL_LETTER_OFFSET;
                                        active_terminal-&gt;keyboard_buffer[active_terminal-&gt;keyboard_buf_idx_tail++] = ascii_from_kb - caps_offset; <span style="font-style: italic">// modify upper case if necessary</span>

                                    }
									<span style="font-weight: bold">else</span>
                                        active_terminal-&gt;keyboard_buffer[active_terminal-&gt;keyboard_buf_idx_tail++] = ascii_special_char_LUT[ascii_from_kb];
								}
								<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span>((shift_flag == 1 &amp;&amp; caps_lock_flag == 1) || (shift_flag == 0 &amp;&amp; caps_lock_flag == 0)) { <span style="font-style: italic">//caps lock + shift should cancel out</span>
									active_terminal-&gt;keyboard_buffer[active_terminal-&gt;keyboard_buf_idx_tail++] = ascii_from_kb; <span style="font-style: italic">// No upper case necessary</span>
								}
							}

							<span style="font-weight: bold">if</span> (active_terminal-&gt;keyboard_buf_idx_tail &gt;= KEYBOARD_BUF_SIZE)
								active_terminal-&gt;keyboard_buf_idx_tail = 0; <span style="font-style: italic">//wrap the tail around</span>

							draw_terminal_to_vga (); <span style="font-style: italic">//draw the kb buffer on the terminal</span>
                        }

                        buf_length = get_keyboard_buffer_length();
                        update_cursor(active_terminal-&gt;cursor_x + buf_length, active_terminal-&gt;cursor_y);

        }
}

 <span style="font-style: italic">/*Function:	keyboard_handler_implementation   </span>
<span style="font-style: italic"> *Description:  Handles interrupts sent from the keyboard by reading the scan code and interpreting the code to generate the appropriate output on </span>
<span style="font-style: italic"> 				the screen. This includes handling capitalization, and also maps control + #&#39;s to test cases. The handler will call a function to update the VGA</span>
<span style="font-style: italic"> 				memory with the current keyboard buffer at the end of the function.</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> Side effects:  Video memory is updated with contents of the keyboard buffer. Keyboard buffer is also updated.</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>

<span style="font-weight: bold">uint32_t</span> read_from_keyboard (<span style="font-weight: bold">uint32_t</span> fd, <span style="font-weight: bold">uint8_t</span> * buf, <span style="font-weight: bold">uint32_t</span> nbytes)
{

	<span style="font-weight: bold">int</span> index;
	<span style="font-weight: bold">uint32_t</span> cursor_y_offset;
    <span style="font-weight: bold">int</span> num_bytes_read = 0;
	nbytes = nbytes &lt; KEYBOARD_BUF_SIZE ? nbytes : KEYBOARD_BUF_SIZE; <span style="font-style: italic">// protect against corrupted/inconsistent parameters</span>
	nbytes = KEYBOARD_BUF_SIZE; <span style="font-style: italic">//remove this after testing completes</span>

    <span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();

    <span style="font-weight: bold">terminal_t</span> * current_terminal = &amp;terminals[cur_pcb-&gt;terminal_idx];

	<span style="font-weight: bold">while</span> (1)
	{
		<span style="font-weight: bold">if</span> (current_terminal-&gt;keyboard_buf_idx_head == current_terminal-&gt;keyboard_buf_idx_tail) <span style="font-style: italic">//if empty, repeat loop</span>
			<span style="font-weight: bold">continue</span>;

		<span style="font-weight: bold">if</span> (current_terminal-&gt;keyboard_buffer[(current_terminal-&gt;keyboard_buf_idx_tail - 1) % KEYBOARD_BUF_SIZE] == <span style="font-style: italic">&#39;\n&#39;</span>) { <span style="font-style: italic">//break loop if circular buffer ends with a newline character</span>
			<span style="font-weight: bold">if</span> (current_terminal-&gt;keyboard_buf_idx_head != current_terminal-&gt;keyboard_buf_idx_tail) <span style="font-style: italic">//because the keyboard interrupt could have come in the middle and have been backspaced, we need to check again</span>
				<span style="font-weight: bold">break</span>;
			current_terminal-&gt;buffer_went_onto_two_lines = 0; <span style="font-style: italic">// reset the double line keyboard buffer for graphical purposes</span>
		}
	}

	index = 0;
	<span style="font-weight: bold">while</span> ((current_terminal-&gt;keyboard_buf_idx_head != current_terminal-&gt;keyboard_buf_idx_tail) &amp;&amp; (index &lt; nbytes)) {
		buf[index++] = current_terminal-&gt;keyboard_buffer [current_terminal-&gt;keyboard_buf_idx_head++];
		<span style="font-weight: bold">if</span> (current_terminal-&gt;keyboard_buf_idx_head &gt;= KEYBOARD_BUF_SIZE)
			current_terminal-&gt;keyboard_buf_idx_head = current_terminal-&gt;keyboard_buf_idx_head % KEYBOARD_BUF_SIZE; <span style="font-style: italic">//always 0</span>
        num_bytes_read++;
	}

	cursor_y_offset = index &lt; VM_NUM_COLS ? 1 : TWO_COLUMN_HEIGHT;
	current_terminal-&gt;cursor_y += cursor_y_offset; <span style="font-style: italic">//send the cursor to the next line </span>
	<span style="font-weight: bold">if</span> (current_terminal-&gt;cursor_y &gt;= VM_NUM_ROWS) {<span style="font-style: italic">//reset the cursor if it goes off the screen</span>
	 	current_terminal-&gt;cursor_y = VM_NUM_ROWS - 1;
	 	scroll_vm ();
	 	draw_terminal_to_vga (); <span style="font-style: italic">//see if this is reallly necessary. it shouldn&#39;t be</span>
	 }
	current_terminal-&gt;cursor_x = 0;
	<span style="font-weight: bold">return</span> num_bytes_read;

}



<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:	rtc_handle_interrupt_implementation     </span>
<span style="font-style: italic"> *Description:  prints out to console interrupt message</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>

<span style="font-weight: bold">void</span> rtc_handle_interrupt_implementation ()
{
	outb(RTC_REG_C_IDX, RTC_COMMAND);
	inb(RTC_DATA);	
	rtc_flag = 1;
	send_eoi(SEND_EOI_2);
}


<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:	periodic_handle_interrupt_implementation     </span>
<span style="font-style: italic"> *Description:  prints out to console interrupt message for periodic interrupts on irq line 8</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> periodic_handle_interrupt_implementation ()
{
    send_eoi(SEND_EOI_3);

	outb(RTC_REG_C_IDX, RTC_COMMAND);
	inb(RTC_DATA);

    cli();
    <span style="font-style: italic">//traverse 2d array top element of each stack row</span>
    <span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
    <span style="font-weight: bold">int</span> scheduled_terminal_idx = (cur_pcb-&gt;terminal_idx + 1) % MAX_NUM_TERMINALS; <span style="font-style: italic">//++scheduled_terminal_idx % MAX_NUM_TERMINALS;</span>
    <span style="font-weight: bold">program_control_block_t</span> * next_pcb = terminal_pcb_stack [scheduled_terminal_idx] [terminal_pcb_stack_tops [scheduled_terminal_idx]-1];
    cur_pcb-&gt;esp0 = tss.esp0;
    cur_pcb-&gt;has_pit_context = 1;
    tss.esp0 = next_pcb-&gt;esp0;
    <span style="font-style: italic">//current state of the current process&#39;s kernel stack: iret context is on top</span>
    asm <span style="font-weight: bold">volatile</span>(
        <span style="font-style: italic">&quot;movl %0, %%eax;&quot;</span> 
        <span style="font-style: italic">&quot;movl %1, %%edx;&quot;</span>
        <span style="font-style: italic">&quot;movl %3, %%edi;&quot;</span>
        <span style="font-style: italic">&quot;movl %%cr3, %%ebx;&quot;</span>
        <span style="font-style: italic">&quot;movl %%ebx, (%%edi); &quot;</span>
        <span style="font-style: italic">&quot;movl %2, %%ebx;&quot;</span>
        <span style="font-style: italic">&quot;movl %%ebx, %%cr3;&quot;</span>
        <span style="font-style: italic">&quot;movl %%esp, 4 (%%eax);&quot;</span> <span style="font-style: italic">//save the kernel stack pointer in the pcb field for esp</span>
        <span style="font-style: italic">&quot;movl %%ebp, 8 (%%eax);&quot;</span>
        <span style="font-style: italic">&quot;movl 4(%%edx), %%esp;&quot;</span> <span style="font-style: italic">//set the kernel stack pointer of the new process</span>
        <span style="font-style: italic">&quot;movl 8(%%edx), %%ebp; &quot;</span>
        <span style="font-style: italic">&quot;movl 12(%%edx), %%ebx;&quot;</span>
        <span style="font-style: italic">&quot;cmpl $1, %%ebx;&quot;</span>
        <span style="font-style: italic">&quot;je has_pit_context_go_to;&quot;</span>
        <span style="font-style: italic">&quot;iret;&quot;</span>
        <span style="font-style: italic">&quot;has_pit_context_go_to:&quot;</span>
        :
        : <span style="font-style: italic">&quot;g&quot;</span> ((<span style="font-weight: bold">uint32_t</span>) cur_pcb), <span style="font-style: italic">&quot;g&quot;</span> ((<span style="font-weight: bold">uint32_t</span>) next_pcb), <span style="font-style: italic">&quot;g&quot;</span> (next_pcb-&gt;cr3), <span style="font-style: italic">&quot;g&quot;</span> ((<span style="font-weight: bold">uint32_t</span>) &amp;(cur_pcb-&gt;cr3)) <span style="font-style: italic">//, &quot;g&quot; (&amp;(tss.esp0)), &quot;g&quot; (next_pcb-&gt;esp0)</span>
        : <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;eax&quot;</span>, <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;edi&quot;</span>, <span style="font-style: italic">&quot;ebx&quot;</span>); 



<span style="font-style: italic">/*</span>


<span style="font-style: italic">	//test_interrupts();</span>
<span style="font-style: italic">	//rtc_write(1024);</span>
<span style="font-style: italic">	if(rtc_disp_toggle) {</span>
<span style="font-style: italic">		uint8_t rtc_char = 0x32;</span>
<span style="font-style: italic">		write_to_terminal(0, &amp;rtc_char, 1);</span>
<span style="font-style: italic">	}</span>
<span style="font-style: italic">	//rtc_flag = 1;</span>


<span style="font-style: italic">*/</span>

}



<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:	rtc_read     </span>
<span style="font-style: italic"> *Description:  returns 0 once an rtc interrupt has occured</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: 0 on success</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> rtc_read(<span style="font-weight: bold">int</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">int</span> nbytes) {
    rtc_flag = 0;
	<span style="font-weight: bold">while</span>(rtc_flag == 0);
	<span style="font-weight: bold">return</span> 0;
}



<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:	rtc_write     </span>
<span style="font-style: italic"> *Description:  sets the interrupt frequency accorinding to the parameter passed</span>
<span style="font-style: italic"> *Input:        4-byte integer that represents the desired interrupt frequency</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: 0 on success, -1 on failure</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> rtc_write(<span style="font-weight: bold">int</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">int</span> nbytes) {
	cli();
    <span style="font-weight: bold">int</span> freq = *((<span style="font-weight: bold">int</span>*)buf);
	<span style="font-weight: bold">int</span> idx = 1; <span style="font-style: italic">// counter</span>
	outb(RTC_REG_A_IDX, RTC_COMMAND);
	<span style="font-weight: bold">uint8_t</span> prev = inb(RTC_DATA);
	<span style="font-weight: bold">uint8_t</span> new_data = prev &amp; 0x0; <span style="font-style: italic">// 0xF0 clears the current rate selection</span>

	<span style="font-style: italic">// checks if desired freq is within range and a power of 2</span>
	<span style="font-weight: bold">if</span>((freq &gt; MAX_FREQ) || (freq &lt; 0) || (((freq &amp; (freq - 1)) != 0))) {
		<span style="font-weight: bold">return</span> ERROR;
	}

	<span style="font-weight: bold">while</span>((freq &gt;&gt; idx) != 1) { <span style="font-style: italic">// find which rate corresponds to the desired freq</span>
		idx++;
	}

	new_data = new_data | rtc_rate[idx - 1]; <span style="font-style: italic">// set new rate value</span>
	outb(RTC_REG_A_IDX, RTC_COMMAND); <span style="font-style: italic">// set new rate value for rtc reg A</span>
    outb (new_data, RTC_DATA);
    sti();
    <span style="font-weight: bold">return</span> 0;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:	rtc_open     </span>
<span style="font-style: italic"> *Description:  opens rtc file so you can read/write</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: 0 on success</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> rtc_open(<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* filename) {
	outb(RTC_REG_A_IDX, RTC_COMMAND); <span style="font-style: italic">// set rate value for rtc reg A to default: 2Hz</span>
    <span style="font-style: italic">//outb (REG_A_VAL, RTC_DATA);</span>

    <span style="font-weight: bold">char</span> tmp_A;
    tmp_A = inb (RTC_DATA); 
    tmp_A = (REG_A_VAL | tmp_A); <span style="font-style: italic">//toggle periodic interrupts hi</span>
    outb (tmp_A, RTC_DATA);
	<span style="font-weight: bold">return</span> 0;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:	rtc_close     </span>
<span style="font-style: italic"> *Description:  closes rtc file so you cant read/write</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: 0 on success</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> rtc_close(<span style="font-weight: bold">int</span> fd) {
    outb(RTC_REG_A_IDX, RTC_COMMAND); <span style="font-style: italic">// set rate value for rtc reg A to default: 2Hz</span>
    <span style="font-style: italic">//outb (REG_A_VAL, RTC_DATA);</span>

    <span style="font-weight: bold">char</span> tmp_A;
    tmp_A = inb (RTC_DATA); 
    tmp_A = (REG_A_VAL | tmp_A); <span style="font-style: italic">//toggle periodic interrupts hi</span>
    outb (tmp_A, RTC_DATA);
	<span style="font-weight: bold">return</span> 0;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:	set_rtc_toggle     </span>
<span style="font-style: italic"> *Description:  sets the toggle flag for rtc telling it to display</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: 0 on success</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> set_rtc_toggle(<span style="font-weight: bold">uint8_t</span> toggle) {
	rtc_disp_toggle = toggle;
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--devoces.h-->
        <section>
            <hnew id="devices.h">devices.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#ifndef _DEVICES_INIT_H</span>
<span style="font-style: italic">#define _DEVICES_INIT_H</span>


<span style="font-style: italic">#include &quot;lib.h&quot;</span>
<span style="font-style: italic">#include &quot;i8259.h&quot;</span>
<span style="font-style: italic">#include &quot;terminal.h&quot;</span>
<span style="font-style: italic">#include &quot;cp2_tests.h&quot;</span>

<span style="font-style: italic">#define KEYBOARD_DATA 0x60</span>
<span style="font-style: italic">#define KEYBOARD_STATUS 0x64</span>
<span style="font-style: italic">#define KEYBOARD_SET_DEFAULT 0xF6</span>
<span style="font-style: italic">#define KEYBOARD_IRQLINE 0x21</span>

<span style="font-style: italic">#define RTC_COMMAND 0x70</span>
<span style="font-style: italic">#define RTC_DATA 0x71</span>
<span style="font-style: italic">#define NMI_ENABLE_BIT 0x80</span>
<span style="font-style: italic">#define RTC_IRQLINE 0x20</span>
<span style="font-style: italic">#define RTC_RATE 0x0F</span>

<span style="font-style: italic">#define MAX_FREQ 1024</span>

<span style="font-style: italic">#define RTC_REG_A_IDX 0x0A</span>
<span style="font-style: italic">#define RTC_REG_B_IDX 0x0B</span>
<span style="font-style: italic">#define RTC_REG_C_IDX 0x0C</span>
<span style="font-style: italic">#define RTC_REG_D_IDX 0x0D</span>

<span style="font-style: italic">#define RTC_INIT_DIVIDER 0x40 </span>
<span style="font-style: italic">#define RTC_PERIODIC_INT_ENABLE 0x20</span>
<span style="font-style: italic">#define RTC_LOWEST_RATE 2</span>

<span style="font-style: italic">#define REG_A_VAL     0x2F  // was 8, but F will init to 2 Hz</span>
<span style="font-style: italic">#define REG_B_VAL     0x40</span>
<span style="font-style: italic">#define REG_C_VAL     0xC0</span>
<span style="font-style: italic">#define REG_D_VAL     0x80</span>

<span style="font-style: italic">#define SEND_EOI_1	  0x21</span>
<span style="font-style: italic">#define SEND_EOI_2	  0x28</span>
<span style="font-style: italic">#define SEND_EOI_3	  0x20</span>

<span style="font-style: italic">#define CHECK_CHAR    0x01</span>

<span style="font-style: italic">#define SCAN_CODE_256 256 //needed???</span>

<span style="font-style: italic">#define BACKSPACE		    -1234</span>
<span style="font-style: italic">#define ESCAPE				-6</span>
<span style="font-style: italic">#define TAB					-5</span>
<span style="font-style: italic">#define SHIFT_DOWN			-4</span>
<span style="font-style: italic">#define SHIFT_RELEASED		-3</span>
<span style="font-style: italic">#define CTRL_DOWN			-2</span>
<span style="font-style: italic">#define CTRL_RELEASED		-7</span>
<span style="font-style: italic">#define L_RELEASED 			-8</span>
<span style="font-style: italic">#define CAPS_LOCK			-9</span>
<span style="font-style: italic">#define ONE_RELEASED		-10</span>
<span style="font-style: italic">#define TWO_RELEASED		-11</span>
<span style="font-style: italic">#define THREE_RELEASED		-12</span>
<span style="font-style: italic">#define FOUR_RELEASED		-13</span>
<span style="font-style: italic">#define FIVE_RELEASED		-14</span>
<span style="font-style: italic">#define ALT_DOWN			-15</span>
<span style="font-style: italic">#define ALT_RELEASED		-16</span>
<span style="font-style: italic">#define F1					-17</span>
<span style="font-style: italic">#define F2					-18</span>
<span style="font-style: italic">#define F3					-19</span>

<span style="font-style: italic">#define TERMINAL_ONE 0</span>
<span style="font-style: italic">#define TERMINAL_TWO 1</span>
<span style="font-style: italic">#define TERMINAL_THREE 2</span>

<span style="font-style: italic">#define TWO_COLUMN_HEIGHT 2</span>


<span style="font-style: italic">#define CAPITAL_LETTER_OFFSET 0x20</span>


<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> ascii_sc_LUT[256];


<span style="font-weight: bold">void</span> init_RTC ();
<span style="font-weight: bold">void</span> init_keyboard ();
<span style="font-weight: bold">void</span> init_ascii_scancode_LUT ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> read_from_keyboard (<span style="font-weight: bold">uint32_t</span> fd, <span style="font-weight: bold">uint8_t</span> * buf, <span style="font-weight: bold">uint32_t</span> nbytes);

<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> keyboard_handler_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> rtc_handle_interrupt_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> set_rtc_toggle(<span style="font-weight: bold">uint8_t</span> toggle);
<span style="font-weight: bold">int</span> rtc_read(<span style="font-weight: bold">int</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">int</span> nbytes);
<span style="font-weight: bold">int</span> rtc_write(<span style="font-weight: bold">int</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">int</span> nbytes);
<span style="font-weight: bold">int</span> rtc_open(<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* filename);
<span style="font-weight: bold">int</span> rtc_close(<span style="font-weight: bold">int</span> fd);

<span style="font-style: italic">#endif    </span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--exceptions.c-->
        <section>
            <hnew id="exceptions.c">exceptions.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#include &quot;exceptions.h&quot;</span>

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     init_idt</span>
<span style="font-style: italic"> *Description:  initializes all 22 exceptions </span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>

<span style="font-style: italic">#define FIRST_HARD_INT_VEC 0x20</span>
<span style="font-style: italic">#define LAST_HARD_INT_VEC 0x21</span>
<span style="font-style: italic">#define SLAVE_IRQ8_VEC 0x28</span>
<span style="font-style: italic">#define SYSTEM_IRQ 0x80</span>
<span style="font-style: italic">#define RING_3 3</span>
<span style="font-style: italic">#define HALT_EXCEPTION_VECTOR 255</span>
<span style="font-style: italic">#define BLUE_SCREEN_ATTR 0x1F</span>
 
<span style="font-weight: bold">void</span> init_idt ()
{

	<span style="font-weight: bold">uint32_t</span>* exception_functions[NUM_IDT_ENTRIES] = {&amp;divide_by_zero_exception, &amp;debugger_exception, &amp;nmi_exception, &amp;breakpoint_exception, &amp;overflow_exception, &amp;bre_exception, &amp;invalid_opcode_exception,
 										&amp;dna_exception, &amp;double_fault_exception, &amp;cso_exception, &amp;invalid_tss_exception, &amp;snp_exception, &amp;ssf_exception, &amp;gpf_exception, &amp;page_fault_exception,
 												&amp;reserved_exception, &amp;x87_fpe_exception, &amp;alignment_check_exception, &amp;machine_check_exception, &amp;simd_fpe_exception, &amp;virtualization_exception };
 	<span style="font-weight: bold">uint32_t</span>* handler_functions [NUM_HANDLERS] = {&amp;periodic_handle_interrupt, &amp;keyboard_handle_interrupt};

	<span style="font-weight: bold">uint32_t</span> * func_ptr;

	<span style="font-weight: bold">int</span> idx;

	
	<span style="font-weight: bold">for</span> (idx = 0; idx &lt; NUM_EXCEPTIONS; idx++) { <span style="font-style: italic">// initialize exception handlers in IDT</span>
			func_ptr = exception_functions[idx];
			SET_IDT_ENTRY (idt[idx], func_ptr);
			idt[idx].seg_selector = KERNEL_CS;						<span style="font-style: italic">//setting the segment selector to the index value </span>
			idt[idx].present = 1;										<span style="font-style: italic">//settin the exception to present</span>
			idt[idx].reserved0 = 0;
			idt[idx].size = 1;
			idt[idx].reserved1 = 1;
			idt[idx].reserved2 = 1;
			idt[idx].reserved3 = 1; <span style="font-style: italic">//1 for excep, 0 for int hand</span>
			idt[idx].reserved4 = 0;
	} 

	<span style="font-style: italic">//init</span>
	<span style="font-weight: bold">for</span> (idx = FIRST_HARD_INT_VEC; idx &lt;= LAST_HARD_INT_VEC; idx++) { <span style="font-style: italic">// initialize device handlers in IDT</span>
		func_ptr = handler_functions[idx-FIRST_HARD_INT_VEC];
		SET_IDT_ENTRY (idt[idx], func_ptr);
		idt[idx].seg_selector = KERNEL_CS;
		idt[idx].present = 1;
		idt[idx].reserved0 = 0;
		idt[idx].size = 1;
		idt[idx].reserved1 = 1;
		idt[idx].reserved2 = 1;
		idt[idx].reserved3 = 0; <span style="font-style: italic">// 0 for int hand</span>
		idt[idx].reserved4 = 0;
		idt[idx].dpl = 0;
	}


	SET_IDT_ENTRY (idt[SLAVE_IRQ8_VEC], &amp;rtc_handle_interrupt);
	idt[SLAVE_IRQ8_VEC].seg_selector = KERNEL_CS;						<span style="font-style: italic">//setting the segment selector to the index value </span>
	idt[SLAVE_IRQ8_VEC].present = 1;										<span style="font-style: italic">//settin the exception to present</span>
	idt[SLAVE_IRQ8_VEC].reserved0 = 0;
	idt[SLAVE_IRQ8_VEC].size = 1;
	idt[SLAVE_IRQ8_VEC].reserved1 = 1;
	idt[SLAVE_IRQ8_VEC].reserved2 = 1;
	idt[SLAVE_IRQ8_VEC].reserved3 = 0; <span style="font-style: italic">//1 for excep, 0 for int hand</span>
	idt[SLAVE_IRQ8_VEC].reserved4 = 0;
	idt[SLAVE_IRQ8_VEC].dpl = 0;


	SET_IDT_ENTRY (idt[SYSTEM_IRQ], &amp;system_call_exception);
	idt[SYSTEM_IRQ].seg_selector = KERNEL_CS;						<span style="font-style: italic">//setting the segment selector to the index value </span>
	idt[SYSTEM_IRQ].present = 1;										<span style="font-style: italic">//settin the exception to present</span>
	idt[SYSTEM_IRQ].reserved0 = 0;
	idt[SYSTEM_IRQ].size = 1;
	idt[SYSTEM_IRQ].reserved1 = 1;
	idt[SYSTEM_IRQ].reserved2 = 1;
	idt[SYSTEM_IRQ].reserved3 = 1; <span style="font-style: italic">//1 for excep, 0 for int hand</span>
	idt[SYSTEM_IRQ].reserved4 = 0;
	idt[SYSTEM_IRQ].dpl = RING_3; <span style="font-style: italic">// set user privilege dpl so that user programs can call into this exceptions </span>

	
}



<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     devide_by_zero_exception_implementation  </span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> divide_by_zero_exception_implementation ()
{

	<span style="font-weight: bold">char</span> * video_memory = (<span style="font-weight: bold">char</span> *) VIDEO_MEM_START_ADDR;
	<span style="font-weight: bold">int</span> i;
	<span style="font-weight: bold">for</span> (i = 0; i &lt; (VM_NUM_COLS * VM_NUM_ROWS) * BYTES_PER_VGA_SQUARE; i += BYTES_PER_VGA_SQUARE)
			video_memory[i] = <span style="font-style: italic">&#39; &#39;</span>;

		printf(<span style="font-style: italic">&quot;Divide by zero exception.&quot;</span>);
		
	<span style="font-weight: bold">for</span> (i = 0; i &lt; (VM_NUM_COLS * VM_NUM_ROWS) * BYTES_PER_VGA_SQUARE; i += BYTES_PER_VGA_SQUARE) 
		video_memory[i+1] = BLUE_SCREEN_ATTR;

	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     debugger_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> debugger_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Debugger exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     nmi_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> nmi_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;non maskable interrupt exception&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     breakpoint_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> breakpoint_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Breakpoint exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     overflow_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> overflow_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Overflow exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     bre_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> bre_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Bound Range Exceeded exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     invalid_opcode_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> invalid_opcode_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Invalid opcode exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     dna_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> dna_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Device not available exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     double_fault_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> double_fault_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Double fault exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     cso_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> cso_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Coprocessor segment overrun exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     invalid_tss_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> invalid_tss_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Invalid task state segment exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     snp_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> snp_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Segment not present exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     ssf_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> ssf_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Stack segment fault exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     gpf_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> gpf_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;General protection fault exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     page_fault_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> page_fault_exception_implementation ()
{
	<span style="font-style: italic">// int tmp;</span>
	<span style="font-style: italic">// asm volatile (&quot;movl %%cr2, %0 &quot;</span>
	<span style="font-style: italic">// 				: &quot;=r&quot; (tmp) ); // get the pcb of the current process</span>

	<span style="font-style: italic">// printf (&quot;%x&quot;, tmp);</span>
	<span style="font-style: italic">//printf(&quot;Page fault exception.&quot;);</span>
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     reserved_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> reserved_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Reserved exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     x87_fpe_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> x87_fpe_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;x87 floating point exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     alignment_check_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> alignment_check_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Alignment check exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     machine_check_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> machine_check_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Machine check exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     simd_fpe_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> simd_fpe_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;SIMD floating point exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     virtualization_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> virtualization_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Virtualization exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     security_exception_implementation</span>
<span style="font-style: italic"> *Description:  prints out statement when exception occurs</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       print statement</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> security_exception_implementation ()
{
	printf(<span style="font-style: italic">&quot;Security exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}

<span style="font-weight: bold">void</span> system_call_exception_implementation () <span style="font-style: italic">//I think we can delete this</span>
{
	printf(<span style="font-style: italic">&quot;System call exception.&quot;</span>);
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;exception_encountered = 1;
	system_halt(HALT_EXCEPTION_VECTOR);
	<span style="font-weight: bold">while</span>(1);
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--exceptions.h-->
        <section>
            <hnew id="exceptions.h">exceptions.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#ifndef EXCEPTIONS_H</span>
<span style="font-style: italic">#define EXCEPTIONS_H</span>

<span style="font-style: italic">#include &quot;x86_desc.h&quot;</span>
<span style="font-style: italic">#include &quot;types.h&quot;</span>
<span style="font-style: italic">#include &quot;devices.h&quot;</span>
<span style="font-style: italic">#include &quot;system_calls.h&quot;</span>

<span style="font-style: italic">#define NUM_EXCEPTIONS 22</span>
<span style="font-style: italic">#define NUM_HANDLERS 2</span>
<span style="font-style: italic">#define NUM_IDT_ENTRIES 24</span>
<span style="font-style: italic">#define VIDEO_MEM_START_ADDR 0xB8000</span>
<span style="font-style: italic">#define VM_NUM_COLS 80</span>
<span style="font-style: italic">#define VM_NUM_ROWS 25</span>

<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> divide_by_zero_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> debugger_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> nmi_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> breakpoint_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> overflow_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> bre_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> invalid_opcode_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> dna_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> double_fault_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> cso_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> invalid_tss_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> snp_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> ssf_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> gpf_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> page_fault_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> reserved_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> x87_fpe_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> alignment_check_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> machine_check_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> simd_fpe_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> virtualization_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> security_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> rtc_handle_interrupt;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> keyboard_handle_interrupt;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> system_call_exception;
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> periodic_handle_interrupt;

<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> divide_by_zero_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> debugger_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> nmi_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> breakpoint_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> overflow_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> bre_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> invalid_opcode_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> dna_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> double_fault_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> cso_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> invalid_tss_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> snp_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> ssf_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> gpf_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> page_fault_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> reserved_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> x87_fpe_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> alignment_check_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> machine_check_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> simd_fpe_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> virtualization_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> security_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> system_call_exception_implementation ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> init_idt ();

<span style="font-style: italic">#endif</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--file_system.c-->
        <section>
            <hnew id="file_system.c">file_system.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">/* </span>
<span style="font-style: italic">The open system call provides access to the file system. The call should find the directory entry corresponding to the</span>
<span style="font-style: italic">named file, allocate an unused file descriptor, and set up any data necessary to handle the given type of file (directory,</span>
<span style="font-style: italic">RTC device, or regular file). If the named file does not exist or no descriptors are free, the call returns -1.</span>
<span style="font-style: italic">*/</span>

<span style="font-style: italic">#include &quot;system_calls.h&quot;</span>

<span style="font-style: italic">#define MASK_TO_PCB 0xFFFFFC00 /*mask out LSBs when in kernel stack to get pointer to pcb */</span>



<span style="font-weight: bold">uint32_t</span> filesys_boot_block_start;
<span style="font-style: italic">//fd_t file_array[ARRAY_SIZE];</span>

<span style="font-style: italic">// void integer_to_ascii(uint32_t size, uint8_t* size_buf);</span>
<span style="font-style: italic">// void print_file_info(uint8_t* default_buf, uint8_t* boot_block, uint8_t* file_name, uint32_t file_type, uint8_t* file_size);</span>


<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:		init_file_system</span>
<span style="font-style: italic"> * Description:		initializes the file system by setting the file system start address to boot bloc start address</span>
<span style="font-style: italic"> * Input:		boot_block_start: holds start address of boot block</span>
<span style="font-style: italic"> * Output:		NONE</span>
<span style="font-style: italic"> * Return Value:	NONE</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> init_file_system (<span style="font-weight: bold">uint32_t</span> boot_block_start)
{
	filesys_boot_block_start = boot_block_start;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     file_read</span>
<span style="font-style: italic"> * Description:  reads data associated with a file</span>
<span style="font-style: italic"> * Input:        file descriptor, ptr to buffer, number of bytes</span>
<span style="font-style: italic"> * Output:       fills terminal buffer with data to be read</span>
<span style="font-style: italic"> * Return value: 0 if initial file position is at or beyond end of file or number of bytes read</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> file_read(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes) {


	<span style="font-weight: bold">program_control_block_t</span> * pcb = (<span style="font-weight: bold">program_control_block_t</span> *)get_pcb_of_cur_process ();

	<span style="font-weight: bold">int32_t</span> bytes_read = read_data(pcb-&gt;file_array[fd].inode, pcb-&gt;file_array[fd].file_pos, buf, nbytes);

	pcb-&gt;file_array[fd].file_pos += bytes_read;
	<span style="font-weight: bold">return</span> bytes_read; <span style="font-style: italic">// make sure tha read data returns 0 when you cant read anymore bytes</span>
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     file_write</span>
<span style="font-style: italic"> * Description:  returns -1 because this system is read-only</span>
<span style="font-style: italic"> * Input:        file descriptor, ptr to buffer, number of bytes</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: -1</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> file_write(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes) {
	<span style="font-weight: bold">return</span> -1; <span style="font-style: italic">// no write functionality supported in this build</span>
}


<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     file_open</span>
<span style="font-style: italic"> * Description:  finds the directory entry associated with file name and assigns it an unused file descriptor</span>
<span style="font-style: italic"> * Input:        name of file to be opened</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: fd on success, -1 on failure (no free file descriptor or non-existent file)</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> file_open(<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* filename) {
	<span style="font-style: italic">// int fd = 2;</span>
	<span style="font-style: italic">// int i;</span>
	<span style="font-style: italic">// dentry_t dentry;</span>
	<span style="font-style: italic">// void* type_0_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {&amp;rtc_open, &amp;rtc_read, &amp;rtc_write, &amp;rtc_close};</span>
	<span style="font-style: italic">// void* type_1_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {&amp;file_open, &amp;dir_read, &amp;file_write, &amp;file_close};</span>
	<span style="font-style: italic">// void* type_2_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {&amp;file_open, &amp;file_read, &amp;file_read, &amp;file_close};</span>

	<span style="font-style: italic">// if(filename[0] == &#39;\0&#39;)</span>
	<span style="font-style: italic">// 	return -1;</span>

	<span style="font-style: italic">// if(read_dentry_by_name(filename, &amp;dentry) != 0) { // check for valid file</span>
	<span style="font-style: italic">// 	return -1;</span>
	<span style="font-style: italic">// }</span>

	<span style="font-style: italic">// program_control_block_t * pcb = (program_control_block_t *)get_pcb_of_cur_process ();</span>


	<span style="font-style: italic">// while(pcb-&gt;file_array[fd].flags != 0) { // check for unused file desciptors</span>
	<span style="font-style: italic">// 	if(fd == ARRAY_SIZE) {</span>
	<span style="font-style: italic">// 		return -1; // if no unused file descriptors return -1</span>
	<span style="font-style: italic">// 	}</span>
	<span style="font-style: italic">// 	fd++;</span>
	<span style="font-style: italic">// }</span>

	<span style="font-style: italic">// pcb-&gt;file_array[fd].flags = 1;</span>
	<span style="font-style: italic">// pcb-&gt;file_array[fd].inode = dentry.inode;</span>
	<span style="font-style: italic">// pcb-&gt;file_array[fd].file_pos = 0;</span>

	<span style="font-style: italic">// switch(dentry.file_type) {</span>
	<span style="font-style: italic">// 	case 0: // RTC</span>
	<span style="font-style: italic">// 		for(i = 0; i &lt; FILE_OP_TABLE_SIZE; i++) {</span>
	<span style="font-style: italic">// 			pcb-&gt;file_array[fd].file_op_table[i] = type_0_file_operations_jump_table[i];</span>
	<span style="font-style: italic">// 		}</span>
	<span style="font-style: italic">// 		rtc_open();</span>
	<span style="font-style: italic">// 		break;</span>
	<span style="font-style: italic">// 	case 1: // directory</span>
	<span style="font-style: italic">// 		for(i = 0; i &lt; FILE_OP_TABLE_SIZE; i++) {</span>
	<span style="font-style: italic">// 			pcb-&gt;file_array[fd].file_op_table[i] = type_1_file_operations_jump_table[i];</span>
	<span style="font-style: italic">// 		}</span>
	<span style="font-style: italic">// 		break;</span>
	<span style="font-style: italic">// 	default: // regular file</span>
	<span style="font-style: italic">// 		for(i = 0; i &lt; FILE_OP_TABLE_SIZE; i++) {</span>
	<span style="font-style: italic">// 			pcb-&gt;file_array[fd].file_op_table[i] = type_2_file_operations_jump_table[i];</span>
	<span style="font-style: italic">// 		}</span>
	<span style="font-style: italic">// 		break;</span>
	<span style="font-style: italic">// }</span>
	<span style="font-style: italic">// return fd;</span>
	<span style="font-weight: bold">return</span> 0;
}


<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     file_close</span>
<span style="font-style: italic"> * Description:  closes specified file descriptor and makes it free to use; should never close default descriptors</span>
<span style="font-style: italic"> * Input:        file descriptor</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: 0 on success, -1 on failure (invalid file descriptor)</span>
<span style="font-style: italic"> */</span>

<span style="font-weight: bold">int</span> file_close(<span style="font-weight: bold">int32_t</span> fd) {

	<span style="font-weight: bold">if</span>(fd &lt; MIN_FD || fd &gt;= MAX_FD) { <span style="font-style: italic">// cannot close default descriptors or invalid descriptors</span>
		<span style="font-weight: bold">return</span> ERROR;
	}

	<span style="font-weight: bold">program_control_block_t</span> * pcb  = (<span style="font-weight: bold">program_control_block_t</span> *)get_pcb_of_cur_process (); 

	pcb-&gt;file_array[fd].flags = 0; <span style="font-style: italic">// indicates the file is no longer in use</span>
	<span style="font-weight: bold">return</span> 0;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     dir_read</span>
<span style="font-style: italic"> * Description:  reads next file in the directory</span>
<span style="font-style: italic"> * Input:        file descriptor, pointer to buffer, number of bytes to be read</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: 0 on success, -1 on failure, 0 if already at least entry</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> dir_read(<span style="font-weight: bold">uint32_t</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes) {
	<span style="font-weight: bold">int</span> i;
	<span style="font-weight: bold">dentry_t</span> dentry;
	<span style="font-weight: bold">program_control_block_t</span> * pcb = (<span style="font-weight: bold">program_control_block_t</span> *)get_pcb_of_cur_process ();

	<span style="font-weight: bold">uint32_t</span> file_pos = pcb-&gt;file_array[fd].file_pos;
	<span style="font-weight: bold">if</span>(file_pos &gt;= MAX_FILES) { <span style="font-style: italic">// max number of files read reached</span>
		file_pos = 0; <span style="font-style: italic">// this resets it to point at the first entry</span>
		<span style="font-weight: bold">return</span> 0; <span style="font-style: italic">// documentation says do this, but then how will it be reset?</span>
	}


	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span>(read_dentry_by_index(file_pos, &amp;dentry) != 0) <span style="font-style: italic">// check for valid file</span>
		<span style="font-weight: bold">return</span> ERROR;

	<span style="font-weight: bold">char</span>* buf_c = (<span style="font-weight: bold">char</span>*)buf;
	<span style="font-weight: bold">for</span>(i = 0; i &lt; nbytes; i++)
		buf_c[i] = dentry.file_name[i];

	pcb-&gt;file_array[fd].file_pos++; <span style="font-style: italic">// increment to next file to be read</span>
	<span style="font-weight: bold">return</span> nbytes;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     read_dentry_by_name</span>
<span style="font-style: italic"> * Description: 	fills dentry with file name file type and inode number for file</span>
<span style="font-style: italic"> * Input:        file name, ptr to dentry_t</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: 0 on success, -1 on failure (non-existent file)</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> read_dentry_by_name (<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* fname, <span style="font-weight: bold">dentry_t</span>* dentry) {
	<span style="font-weight: bold">uint8_t</span> *boot_block = (<span style="font-weight: bold">uint8_t</span> *)filesys_boot_block_start; <span style="font-style: italic">//align 1??????????????</span>
	<span style="font-weight: bold">int</span> i, j;
	<span style="font-style: italic">//uint8_t buf [33];</span>
	<span style="font-weight: bold">uint8_t</span> name_found_flag; <span style="font-style: italic">//flag indicates that the fname and the current dentry name match</span>




	<span style="font-weight: bold">for</span> (i = OFFSET - DENTRY_SIZE; i &lt; OFFSET + SIXTEEN * DENTRY_SIZE; i+= DENTRY_SIZE)  {
		name_found_flag = 1;
		<span style="font-weight: bold">for</span> (j = 0; j &lt; F_NAME_SIZE; j++) {
			<span style="font-weight: bold">if</span> ((fname[j] == <span style="font-style: italic">&#39;\0&#39;</span>) || (boot_block[i+j] == <span style="font-style: italic">&#39;\0&#39;</span>)) {
				<span style="font-weight: bold">if</span> (!((fname[j] == <span style="font-style: italic">&#39;\0&#39;</span>) &amp;&amp; (boot_block[i+j] == <span style="font-style: italic">&#39;\0&#39;</span>)))
					name_found_flag = 0;
				<span style="font-weight: bold">break</span>;
			}
			<span style="font-style: italic">//else if (fname[j] == &#39;\0&#39; || boot_block[i+j] == &#39;\0&#39;) { //one terminates before the other</span>
			<span style="font-style: italic">//	name_found_flag = 0;</span>
			<span style="font-style: italic">//	break;</span>
			<span style="font-style: italic">//}</span>
			<span style="font-weight: bold">if</span> (fname[j] != boot_block[i+j]) {
				name_found_flag = 0;
				<span style="font-weight: bold">break</span>;
			}
		}
		
		<span style="font-weight: bold">if</span> (name_found_flag) {
			<span style="font-weight: bold">for</span> (j = 0; j &lt; F_NAME_SIZE; j++) {
				dentry-&gt;file_name[j] = boot_block[i+j];
				<span style="font-weight: bold">if</span> (fname[j] == <span style="font-style: italic">&#39;\0&#39;</span>)
					<span style="font-weight: bold">break</span>;
			}
			dentry-&gt;file_type = *((<span style="font-weight: bold">uint32_t</span> *) &amp;boot_block[i+F_TYPE_IN_STRUCT]);
			dentry-&gt;inode = *((<span style="font-weight: bold">uint32_t</span> *) &amp;boot_block[i+INODE_IN_STRUCT]);
			<span style="font-style: italic">//write_to_terminal (0, (uint8_t*)dentry-&gt;file_name, F_NAME_SIZE);</span>
			<span style="font-weight: bold">if</span> (fname[0] == <span style="font-style: italic">&#39;.&#39;</span>)
				dentry-&gt;file_type = 1;
			<span style="font-weight: bold">return</span> 0;
		}
	}
	

	<span style="font-weight: bold">return</span> ERROR;

}


<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     read_dentry_by_index</span>
<span style="font-style: italic"> * Description: 	fills dentry with file name file type and inode number for file</span>
<span style="font-style: italic"> * Input:        inode index, ptr to dentry_t</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: 0 on success, -1 on failure (invalid index)</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">uint32_t</span> read_dentry_by_index (<span style="font-weight: bold">uint32_t</span> index, <span style="font-weight: bold">dentry_t</span>* dentry) {

	<span style="font-weight: bold">uint8_t</span> *boot_block = (<span style="font-weight: bold">uint8_t</span> *)  filesys_boot_block_start;

	<span style="font-weight: bold">int</span> j;
	<span style="font-style: italic">//uint8_t buf [33];</span>
	<span style="font-style: italic">//uint8_t name_found_flag; //flag indicates that the fname and the current dentry name match</span>
	<span style="font-style: italic">//char new_lin = &#39;\n&#39;;</span>
	<span style="font-weight: bold">int</span> offset = DENTRY_SIZE + index * DENTRY_SIZE;

	<span style="font-weight: bold">for</span> (j = 0; j &lt; F_NAME_SIZE; j++) {
		dentry-&gt;file_name[j] = boot_block[offset + j];
		<span style="font-weight: bold">if</span> (dentry-&gt;file_name[j] == <span style="font-style: italic">&#39;\0&#39;</span>) 
			<span style="font-weight: bold">break</span>;
	}

	dentry-&gt;file_type = *((<span style="font-weight: bold">uint32_t</span> *) &amp;boot_block[offset+F_TYPE_IN_STRUCT]);
	dentry-&gt;inode = *((<span style="font-weight: bold">uint32_t</span> *) &amp;boot_block[offset+INODE_IN_STRUCT]);

	<span style="font-style: italic">// write_to_terminal (0, (uint8_t*)dentry-&gt;file_name, F_NAME_SIZE);</span>
	<span style="font-style: italic">// write_to_terminal (0, (uint8_t*)&amp;new_lin, 1);</span>

	<span style="font-weight: bold">return</span> 0;
}



<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     read_data</span>
<span style="font-style: italic"> * Description: 	reads file up to length in bytes </span>
<span style="font-style: italic"> * Input:        inode idx, memory offset, buf ptr, length to be read</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: Number of bytes read</span>
<span style="font-style: italic"> */</span>

<span style="font-weight: bold">uint32_t</span> read_data (<span style="font-weight: bold">uint32_t</span> inode, <span style="font-weight: bold">uint32_t</span> offset, <span style="font-weight: bold">uint8_t</span>* buf, <span style="font-weight: bold">uint32_t</span> length) {
	<span style="font-weight: bold">uint8_t</span> *boot_block = (<span style="font-weight: bold">uint8_t</span> *)  filesys_boot_block_start;
	<span style="font-weight: bold">uint32_t</span> num_inodes = *(<span style="font-weight: bold">uint32_t</span> * )(&amp;boot_block [INODE]);
	<span style="font-weight: bold">uint32_t</span> num_data_blocks = *(<span style="font-weight: bold">uint32_t</span> * )(&amp;boot_block [DATA_BLOCKS]); <span style="font-style: italic">//needs verification</span>
	<span style="font-weight: bold">uint32_t</span> *inode_block = (<span style="font-weight: bold">uint32_t</span>*)((inode + 1) * DATA_BLOCK_SIZE + (<span style="font-weight: bold">uint32_t</span>)filesys_boot_block_start);
	<span style="font-weight: bold">uint32_t</span> file_length = inode_block[0];
	<span style="font-weight: bold">uint8_t</span> * data_block;

	<span style="font-weight: bold">int</span> bytes_read = 0;
	<span style="font-weight: bold">int</span> data_block_idx = 0;
	<span style="font-weight: bold">int</span> blocks_read = 0;
	<span style="font-weight: bold">int</span> idx_in_buf = 0;
	<span style="font-weight: bold">int</span> data_block_offset = offset / DATA_BLOCK_SIZE;
	<span style="font-weight: bold">int</span> idx_within_data_block = offset % DATA_BLOCK_SIZE; <span style="font-style: italic">//offset the first db by the remainder</span>

	<span style="font-weight: bold">if</span> (inode &gt;= num_inodes)
		<span style="font-weight: bold">return</span> 0; <span style="font-style: italic">//inode does not exist, return failure indicator</span>

	<span style="font-style: italic">//length = (length) &lt; file_length ? length : file_length; //if the length specified is greater than the actual length of the file, set it to the file length</span>
	<span style="font-weight: bold">if</span> (length + offset &gt; file_length)
		length = file_length - offset;
	<span style="font-style: italic">//length = (length) &lt; file_length </span>
	<span style="font-weight: bold">while</span> (idx_in_buf &lt; length) {
		data_block_idx = inode_block[1 + data_block_offset + blocks_read++];
		<span style="font-weight: bold">if</span> (data_block_idx &lt; 0 || data_block_idx &gt;= num_data_blocks) <span style="font-weight: bold">return</span> 0;
		data_block = (<span style="font-weight: bold">uint8_t</span>*)((1 + num_inodes + data_block_idx) * DATA_BLOCK_SIZE + (<span style="font-weight: bold">uint32_t</span>)filesys_boot_block_start); <span style="font-style: italic">//points to the first data block</span>
		<span style="font-weight: bold">while</span> ((idx_in_buf &lt; length) &amp;&amp; (idx_within_data_block &lt; DATA_BLOCK_SIZE)) {
			buf[idx_in_buf++] = data_block[idx_within_data_block++];
			bytes_read++;
		}
		idx_within_data_block = 0; <span style="font-style: italic">//update at the end, because may have an offset on the first data block</span>
	}
	<span style="font-weight: bold">return</span> bytes_read;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:     get_file_sys_mem_start()</span>
<span style="font-style: italic"> * Description: 	retrieves file system memory start</span>
<span style="font-style: italic"> * Input:        none</span>
<span style="font-style: italic"> * Output:       none</span>
<span style="font-style: italic"> * Return value: retrieves file system memory start</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">uint32_t</span> get_file_sys_mem_start() {
	<span style="font-weight: bold">return</span> filesys_boot_block_start;
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--file_system.h-->
        <section>
            <hnew id="file_system.h">file_system.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#ifndef _FILE_SYS_H</span>
<span style="font-style: italic">#define _FILE_SYS_H</span>

<span style="font-style: italic">#include &quot;lib.h&quot;</span>
<span style="font-style: italic">#include &quot;system_calls.h&quot;</span>
<span style="font-style: italic">#include &quot;devices.h&quot;</span>
<span style="font-style: italic">#include &quot;terminal.h&quot; //may remove, testing purposes only</span>
<span style="font-style: italic">#include &quot;file_system.h&quot;</span>



<span style="font-weight: bold">typedef</span> <span style="font-weight: bold">struct</span> dentry {
	<span style="font-weight: bold">char</span> file_name [32];
	<span style="font-weight: bold">uint32_t</span> file_type;
	<span style="font-weight: bold">uint32_t</span> inode;
	<span style="font-weight: bold">uint8_t</span> reserved [24];
} <span style="font-weight: bold">dentry_t</span>;


<span style="font-style: italic">/*</span>
<span style="font-style: italic">I moved this to system_calls where it belongs now</span>
<span style="font-style: italic">typedef struct {</span>
<span style="font-style: italic">	uint32_t* file_op_table_ptr;</span>
<span style="font-style: italic">	uint32_t inode;</span>
<span style="font-style: italic">	uint32_t file_pos;</span>
<span style="font-style: italic">	uint32_t flags;</span>
<span style="font-style: italic">} fd_t;</span>
<span style="font-style: italic">*/</span>
<span style="font-style: italic">#define MAX_FILES 16</span>
<span style="font-style: italic">#define MAX_FD 8</span>

 		<span style="font-style: italic">//for init_file_system</span>
<span style="font-style: italic">#define ARRAY_SIZE		8</span>
  		<span style="font-style: italic">//for read_dentry_by_name </span>
<span style="font-style: italic">#define OFFSET			128</span>
<span style="font-style: italic">#define BUF_SIZE		64</span>
<span style="font-style: italic">#define SIXTEEN			16</span>
<span style="font-style: italic">#define DENTRY_SIZE 	64</span>

<span style="font-style: italic">#define F_NAME_SIZE	32</span>

  		<span style="font-style: italic">//for read_dentry_by_index</span>
<span style="font-style: italic">#define F_TYPE_IN_STRUCT 32</span>
<span style="font-style: italic">#define INODE_IN_STRUCT	36</span>
<span style="font-style: italic">#define DATA_BLOCK_SIZE 4096</span>


 <span style="border: 1px solid #FF0000">#</span>define INODE 4
 <span style="border: 1px solid #FF0000">#</span>define DATA_BLOCKS 8
  		<span style="font-style: italic">//for read_data</span>

  		
<span style="font-style: italic">//   		//for print_out_the_file_directory</span>
<span style="font-style: italic">// #define LAST_IDX		32	</span>
<span style="font-style: italic">// #define BUFFER_SIZE		33</span>

<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> dir_read(<span style="font-weight: bold">uint32_t</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes);

<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> file_read(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes);
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> file_write(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes);
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> file_open(<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* filename);
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> file_close(<span style="font-weight: bold">int32_t</span> fd);

<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> read_dentry_by_name (<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* fname, <span style="font-weight: bold">dentry_t</span>* dentry);
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> read_dentry_by_index (<span style="font-weight: bold">uint32_t</span> index, <span style="font-weight: bold">dentry_t</span>* dentry);
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> read_data (<span style="font-weight: bold">uint32_t</span> inode, <span style="font-weight: bold">uint32_t</span> offset, <span style="font-weight: bold">uint8_t</span>* buf, <span style="font-weight: bold">uint32_t</span> length);
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> init_file_system (<span style="font-weight: bold">uint32_t</span> boot_block_start);

<span style="font-style: italic">// extern void print_out_the_file_directory ();</span>
<span style="font-style: italic">// extern void show_file_by_name(const uint8_t* file_name);</span>
<span style="font-style: italic">// extern void show_file_by_idx(uint32_t idx);</span>

<span style="font-weight: bold">uint32_t</span> get_file_sys_mem_start();

<span style="font-style: italic">#endif /* _FILE_SYS_H */</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--kernel.c-->
        <section>
            <hnew id="kernel.c">kernel.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">/* kernel.c - the C part of the kernel</span>
<span style="font-style: italic"> * vim:ts=4 noexpandtab</span>
<span style="font-style: italic"> */</span>

<span style="font-style: italic">#include &quot;multiboot.h&quot;</span>
<span style="font-style: italic">#include &quot;x86_desc.h&quot;</span>
<span style="font-style: italic">#include &quot;lib.h&quot;</span>
<span style="font-style: italic">#include &quot;i8259.h&quot;</span>
<span style="font-style: italic">#include &quot;debug.h&quot;</span>
<span style="font-style: italic">#include &quot;paging.h&quot;</span>
<span style="font-style: italic">#include &quot;devices.h&quot;</span>
<span style="font-style: italic">#include &quot;exceptions.h&quot;</span>
<span style="font-style: italic">#include &quot;file_system.h&quot;</span>
<span style="font-style: italic">#include &quot;terminal.h&quot;</span>
<span style="font-style: italic">#include &quot;system_calls.h&quot;</span>
<span style="font-style: italic">#include &quot;cp2_tests.h&quot;</span>


<span style="font-style: italic">#define SHELL_WORD_SIZE 6</span>
<span style="font-style: italic">#define COLOR_SCALE 13</span>
<span style="font-style: italic">#define BACKGRND_ATTRIBUTE 0x0F</span>

<span style="font-style: italic">/* Macros. */</span>
<span style="font-style: italic">/* Check if the bit BIT in FLAGS is set. */</span>
<span style="font-style: italic">#define CHECK_FLAG(flags,bit)   ((flags) &amp; (1 &lt;&lt; (bit)))</span>

<span style="font-style: italic">/* Check if MAGIC is valid and print the Multiboot information structure</span>
<span style="font-style: italic">   pointed by ADDR. */</span>
<span style="font-weight: bold">void</span>
entry (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">long</span> magic, <span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">long</span> addr)
{
	<span style="font-weight: bold">multiboot_info_t</span> *mbi;

	<span style="font-style: italic">/* Clear the screen. */</span>
	clear();

	<span style="font-style: italic">/* Am I booted by a Multiboot-compliant boot loader? */</span>
	<span style="font-weight: bold">if</span> (magic != MULTIBOOT_BOOTLOADER_MAGIC)
	{
		printf (<span style="font-style: italic">&quot;Invalid magic number: 0x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>, (<span style="font-weight: bold">unsigned</span>) magic);
		<span style="font-weight: bold">return</span>;
	}

	<span style="font-style: italic">/* Set MBI to the address of the Multiboot information structure. */</span>
	mbi = (<span style="font-weight: bold">multiboot_info_t</span> *) addr;

	<span style="font-style: italic">/* Print out the flags. */</span>
	printf (<span style="font-style: italic">&quot;flags = 0x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>, (<span style="font-weight: bold">unsigned</span>) mbi-&gt;flags);

	<span style="font-style: italic">/* Are mem_* valid? */</span>
	<span style="font-weight: bold">if</span> (CHECK_FLAG (mbi-&gt;flags, 0))
		printf (<span style="font-style: italic">&quot;mem_lower = %uKB, mem_upper = %uKB</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>,
				(<span style="font-weight: bold">unsigned</span>) mbi-&gt;mem_lower, (<span style="font-weight: bold">unsigned</span>) mbi-&gt;mem_upper);

	<span style="font-style: italic">/* Is boot_device valid? */</span>
	<span style="font-weight: bold">if</span> (CHECK_FLAG (mbi-&gt;flags, 1))
		printf (<span style="font-style: italic">&quot;boot_device = 0x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>, (<span style="font-weight: bold">unsigned</span>) mbi-&gt;boot_device);

	<span style="font-style: italic">/* Is the command line passed? */</span>
	<span style="font-weight: bold">if</span> (CHECK_FLAG (mbi-&gt;flags, 2))
		printf (<span style="font-style: italic">&quot;cmdline = %s</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>, (<span style="font-weight: bold">char</span> *) mbi-&gt;cmdline);

	<span style="font-weight: bold">if</span> (CHECK_FLAG (mbi-&gt;flags, 3)) {
		<span style="font-weight: bold">int</span> mod_count = 0;
		<span style="font-weight: bold">int</span> i;
		<span style="font-weight: bold">module_t</span>* mod = (<span style="font-weight: bold">module_t</span>*)mbi-&gt;mods_addr;
		<span style="font-weight: bold">while</span>(mod_count &lt; mbi-&gt;mods_count) {
			printf(<span style="font-style: italic">&quot;Module %d loaded at address: 0x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>, mod_count, (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span>)mod-&gt;mod_start);
			printf(<span style="font-style: italic">&quot;Module %d ends at address: 0x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>, mod_count, (<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">int</span>)mod-&gt;mod_end);
			printf(<span style="font-style: italic">&quot;First few bytes of module:</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			<span style="font-weight: bold">for</span>(i = 0; i&lt;16; i++) {
				printf(<span style="font-style: italic">&quot;0x%x &quot;</span>, *((<span style="font-weight: bold">char</span>*)(mod-&gt;mod_start+i)));
			}
			printf(<span style="font-style: italic">&quot;</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
			mod_count++;
			mod++;
		}
	}
	<span style="font-style: italic">/* Bits 4 and 5 are mutually exclusive! */</span>
	<span style="font-weight: bold">if</span> (CHECK_FLAG (mbi-&gt;flags, 4) &amp;&amp; CHECK_FLAG (mbi-&gt;flags, 5))
	{
		printf (<span style="font-style: italic">&quot;Both bits 4 and 5 are set.</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);
		<span style="font-weight: bold">return</span>;
	}

	<span style="font-style: italic">/* Is the section header table of ELF valid? */</span>
	<span style="font-weight: bold">if</span> (CHECK_FLAG (mbi-&gt;flags, 5))
	{
		<span style="font-weight: bold">elf_section_header_table_t</span> *elf_sec = &amp;(mbi-&gt;elf_sec);

		printf (<span style="font-style: italic">&quot;elf_sec: num = %u, size = 0x%#x,&quot;</span>
				<span style="font-style: italic">&quot; addr = 0x%#x, shndx = 0x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>,
				(<span style="font-weight: bold">unsigned</span>) elf_sec-&gt;num, (<span style="font-weight: bold">unsigned</span>) elf_sec-&gt;size,
				(<span style="font-weight: bold">unsigned</span>) elf_sec-&gt;addr, (<span style="font-weight: bold">unsigned</span>) elf_sec-&gt;shndx);
	}

	<span style="font-style: italic">/* Are mmap_* valid? */</span>
	<span style="font-weight: bold">if</span> (CHECK_FLAG (mbi-&gt;flags, 6))
	{
		<span style="font-weight: bold">memory_map_t</span> *mmap;

		printf (<span style="font-style: italic">&quot;mmap_addr = 0x%#x, mmap_length = 0x%x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>,
				(<span style="font-weight: bold">unsigned</span>) mbi-&gt;mmap_addr, (<span style="font-weight: bold">unsigned</span>) mbi-&gt;mmap_length);
		<span style="font-weight: bold">for</span> (mmap = (<span style="font-weight: bold">memory_map_t</span> *) mbi-&gt;mmap_addr;
				(<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">long</span>) mmap &lt; mbi-&gt;mmap_addr + mbi-&gt;mmap_length;
				mmap = (<span style="font-weight: bold">memory_map_t</span> *) ((<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">long</span>) mmap
					+ mmap-&gt;size + <span style="font-weight: bold">sizeof</span> (mmap-&gt;size)))
			printf (<span style="font-style: italic">&quot; size = 0x%x,     base_addr = 0x%#x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>
					<span style="font-style: italic">&quot;     type = 0x%x,  length    = 0x%#x%#x</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>,
					(<span style="font-weight: bold">unsigned</span>) mmap-&gt;size,
					(<span style="font-weight: bold">unsigned</span>) mmap-&gt;base_addr_high,
					(<span style="font-weight: bold">unsigned</span>) mmap-&gt;base_addr_low,
					(<span style="font-weight: bold">unsigned</span>) mmap-&gt;type,
					(<span style="font-weight: bold">unsigned</span>) mmap-&gt;length_high,
					(<span style="font-weight: bold">unsigned</span>) mmap-&gt;length_low);
	}

	<span style="font-style: italic">/* Construct an LDT entry in the GDT */</span>
	{
		<span style="font-weight: bold">seg_desc_t</span> the_ldt_desc;
		the_ldt_desc.granularity    = 0;
		the_ldt_desc.opsize         = 1;
		the_ldt_desc.reserved       = 0;
		the_ldt_desc.avail          = 0;
		the_ldt_desc.present        = 1;
		the_ldt_desc.dpl            = 0x0;
		the_ldt_desc.sys            = 0;
		the_ldt_desc.type           = 0x2;

		SET_LDT_PARAMS(the_ldt_desc, &amp;ldt, ldt_size);
		ldt_desc_ptr = the_ldt_desc;
		lldt(KERNEL_LDT);
	}

	<span style="font-style: italic">/* Construct a TSS entry in the GDT */</span>
	{
		<span style="font-weight: bold">seg_desc_t</span> the_tss_desc;
		the_tss_desc.granularity    = 0;
		the_tss_desc.opsize         = 0;
		the_tss_desc.reserved       = 0;
		the_tss_desc.avail          = 0;
		the_tss_desc.seg_lim_19_16  = TSS_SIZE &amp; 0x000F0000;
		the_tss_desc.present        = 1;
		the_tss_desc.dpl            = 0x0;
		the_tss_desc.sys            = 0;
		the_tss_desc.type           = 0x9;
		the_tss_desc.seg_lim_15_00  = TSS_SIZE &amp; 0x0000FFFF;

		SET_TSS_PARAMS(the_tss_desc, &amp;tss, tss_size);

		tss_desc_ptr = the_tss_desc;

		tss.ldt_segment_selector = KERNEL_LDT;
		tss.ss0 = KERNEL_DS;
		tss.esp0 = 0x800000;
		ltr(KERNEL_TSS);
	}

	init_idt (); <span style="font-style: italic">//fill 22 exceptions, rtc and keyboard exceptions in idt</span>

	init_file_system ((<span style="font-weight: bold">uint32_t</span>) ((<span style="font-weight: bold">module_t</span>*)mbi-&gt;mods_addr)-&gt;mod_start); <span style="font-style: italic">// must be done before paging, because module ptrs are in first block</span>

	init_paging();	
	<span style="font-style: italic">/* Init the PIC */</span>
	
	active_terminal = &amp;terminals[0]; <span style="font-style: italic">//start with the first terminal</span>
	active_terminal-&gt;video_memory_start = (<span style="font-weight: bold">uint8_t</span> *) VIDEO_MEM_START_ADDR;
	active_terminal-&gt;terminal_idx = 0;
	terminal_video_back_pages = (<span style="font-weight: bold">uint32_t</span> *) PHYS_ADDR_VIDEO_BACK_PAGES;

	<span style="font-weight: bold">int</span> i, j;
	<span style="font-weight: bold">for</span> (i = 0; i &lt; MAX_NUM_TERMINALS; i++) {
		terminals[i].terminal_idx = i;
		execute_init_shell (i);
		terminals[i].init_shell_pid = i;
		terminals[i].video_memory_start = (<span style="font-weight: bold">uint8_t</span> *) &amp;terminal_video_back_pages [i * PAGE_SIZE_32b];
		<span style="font-weight: bold">for</span> (j = 0; j &lt; FOUR_KB; j += BYTES_PER_VGA_SQUARE) {
			*((<span style="font-weight: bold">uint8_t</span> *) (terminals[i].video_memory_start + j + 1)) = terminals[i].terminal_idx * COLOR_SCALE;
			*((<span style="font-weight: bold">uint8_t</span> *) (terminals[i].video_memory_start + j + 1)) &amp;= BACKGRND_ATTRIBUTE;
		}
	}
	
	i8259_init();
	<span style="font-style: italic">/* Initialize devices, memory, filesystem, enable device interrupts on the</span>
<span style="font-style: italic">	 * PIC, any other initialization stuff... */</span>
	init_keyboard();
	init_RTC();
	<span style="font-style: italic">//init_file_system (mod-&gt;mod_start);</span>
	<span style="font-style: italic">//asm(&quot;int $0x10&quot;);</span>
	<span style="font-style: italic">/* Enable interrupts */</span>
	<span style="font-style: italic">/* Do not enable the following until after you have set up your</span>
<span style="font-style: italic">	 * IDT correctly otherwise QEMU will triple fault and simple close</span>
<span style="font-style: italic">	 * without showing you any output */</span>
	printf(<span style="font-style: italic">&quot;Enabling Interrupts</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">&quot;</span>);



	clear_terminal();

	<span style="font-weight: bold">uint8_t</span> file_name [SHELL_WORD_SIZE] = {<span style="font-style: italic">&#39;s&#39;</span>, <span style="font-style: italic">&#39;h&#39;</span>, <span style="font-style: italic">&#39;e&#39;</span>, <span style="font-style: italic">&#39;l&#39;</span>, <span style="font-style: italic">&#39;l&#39;</span>, <span style="font-style: italic">&#39;\0&#39;</span> };

	terminals[0].video_memory_start = (<span style="font-weight: bold">uint8_t</span> *) VIDEO_MEM_START_ADDR;
	terminal_pcb_stack_tops [terminals[0].terminal_idx] = 0;
	available_pids[0] = 0;
	system_execute(file_name);
	sti();


	<span style="font-style: italic">/* Spin (nicely, so we don&#39;t chew up cycles) */</span>
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;.1: hlt; jmp .1;&quot;</span>);
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--i8259.c-->
        <section>
            <hnew id="i8259.c">i8259.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">/* i8259.c - Functions to interact with the 8259 interrupt controller</span>
<span style="font-style: italic"> * vim:ts=4 noexpandtab</span>
<span style="font-style: italic"> */</span>

<span style="font-style: italic">#include &quot;i8259.h&quot;</span>
<span style="font-style: italic">#include &quot;lib.h&quot;</span>

<span style="font-style: italic">/* Interrupt masks to determine which interrupts</span>
<span style="font-style: italic"> * are enabled and disabled */</span>
<span style="font-weight: bold">uint8_t</span> master_mask; <span style="font-style: italic">/* IRQs 0-7 */</span>
<span style="font-weight: bold">uint8_t</span> slave_mask; <span style="font-style: italic">/* IRQs 8-15 */</span>

<span style="font-style: italic">/* Initialize the 8259 PIC */</span>
<span style="font-weight: bold">void</span>
i8259_init(<span style="font-weight: bold">void</span>)
{
		<span style="font-style: italic">//spin lock</span>
	

	disable_all_irqs();	

	outb (ICW1, MASTER_8259_PORT); <span style="font-style: italic">// send initialization word to master. Indicate that ICW4 will be included</span>
	outb (ICW1, SLAVE_8259_PORT); <span style="font-style: italic">// send initialization word to slave. Indicate that ICW4 will be included</span>

	outb (ICW2_MASTER, MASTER_8259_PORT+1);
	outb (ICW2_SLAVE, SLAVE_8259_PORT+1);

	outb (ICW3_MASTER, MASTER_8259_PORT+1);
	outb (ICW3_SLAVE, SLAVE_8259_PORT+1);

	outb (ICW4, MASTER_8259_PORT+1);
	outb (ICW4, MASTER_8259_PORT+1);

}

<span style="font-style: italic">/* Enable (unmask) the specified IRQ */</span>
<span style="font-weight: bold">void</span>
enable_irq(<span style="font-weight: bold">uint32_t</span> irq_num)
{
	<span style="font-weight: bold">uint8_t</span> bitmask = inb (MASTER_8259_PORT+1);
	<span style="font-weight: bold">uint8_t</span> toggle = 1;
	<span style="font-weight: bold">if</span> (irq_num &gt;= MASTER_IRQ_0 &amp;&amp; irq_num &lt;= MASTER_IRQ_7) {
		irq_num -= MASTER_IRQ_0;
		toggle = toggle &lt;&lt; irq_num;
	}
	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (irq_num &gt;= SLAVE_IRQ_0 &amp;&amp; irq_num &lt;= SLAVE_IRQ_7) {
		irq_num -= SLAVE_IRQ_0;
		toggle = toggle &lt;&lt; irq_num;
	}
	bitmask = bitmask &amp; ~(toggle);
	outb (bitmask, MASTER_8259_PORT+1);
}

<span style="font-style: italic">/* Disable (mask) the specified IRQ */</span>
<span style="font-weight: bold">void</span>
disable_irq(<span style="font-weight: bold">uint32_t</span> irq_num)
{
	<span style="font-weight: bold">uint8_t</span> bitmask = inb (MASTER_8259_DATA);
	<span style="font-weight: bold">uint8_t</span> toggle = 1;
	<span style="font-weight: bold">if</span> (irq_num &gt;= MASTER_IRQ_0 &amp;&amp; irq_num &lt;= MASTER_IRQ_7) {
		irq_num -= MASTER_IRQ_0;
		toggle = toggle &lt;&lt; irq_num;
	}
	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (irq_num &gt;= SLAVE_IRQ_0 &amp;&amp; irq_num &lt;= SLAVE_IRQ_7) {
		irq_num -= SLAVE_IRQ_0;
		toggle = toggle &lt;&lt; irq_num;
	}
	bitmask = bitmask &amp; toggle;
	outb (bitmask, MASTER_8259_DATA);
}

<span style="font-weight: bold">void</span> disable_all_irqs ()
{
	outb(PORT_DISABLE_IRQS, MASTER_8259_DATA);
	outb(PORT_DISABLE_IRQS, SLAVE_8259_DATA);
}

<span style="font-style: italic">/* Send end-of-interrupt signal for the specified IRQ */</span>
<span style="font-weight: bold">void</span>
send_eoi(<span style="font-weight: bold">uint32_t</span> irq_num)
{
	<span style="font-style: italic">// uint8_t irq_bit = 1 &lt;&lt; irq_num;</span>
	<span style="font-weight: bold">uint8_t</span> eoi;
	<span style="font-weight: bold">if</span> (irq_num &gt;= MASTER_IRQ_0 &amp;&amp; irq_num &lt;= MASTER_IRQ_7) {
		irq_num = irq_num - MASTER_IRQ_0;
		eoi = EOI | irq_num;
		outb (eoi, MASTER_8259_PORT);	
	}
	<span style="font-weight: bold">if</span> (irq_num &gt;= SLAVE_IRQ_0 &amp;&amp; irq_num &lt;= SLAVE_IRQ_7) {
		irq_num = irq_num - SLAVE_IRQ_0;
		eoi = EOI | irq_num;
		outb (eoi, SLAVE_8259_PORT);
		eoi = EOI | EOI_FLAGS_SLAVE;
		outb (eoi, MASTER_8259_PORT);	
			
	}
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        
        <!--lib.c-->
        <section>
            <hnew id="lib.c">lib.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">/* lib.c - Some basic library functions (printf, strlen, etc.)</span>
<span style="font-style: italic"> * vim:ts=4 noexpandtab</span>
<span style="font-style: italic"> */</span>

<span style="font-style: italic">#include &quot;lib.h&quot;</span>
<span style="font-style: italic">#define VIDEO 0xB8000</span>
<span style="font-style: italic">#define NUM_COLS 80</span>
<span style="font-style: italic">#define NUM_ROWS 25</span>
<span style="font-style: italic">#define ATTRIB 0x7</span>

<span style="font-weight: bold">static</span> <span style="font-weight: bold">int</span> screen_x;
<span style="font-weight: bold">static</span> <span style="font-weight: bold">int</span> screen_y;
<span style="font-weight: bold">static</span> <span style="font-weight: bold">char</span>* video_mem = (<span style="font-weight: bold">char</span> *)VIDEO;

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void clear(void);</span>
<span style="font-style: italic">*   Inputs: void</span>
<span style="font-style: italic">*   Return Value: none</span>
<span style="font-style: italic">*	Function: Clears video memory</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">void</span>
clear(<span style="font-weight: bold">void</span>)
{
    <span style="font-weight: bold">int32_t</span> i;
    <span style="font-weight: bold">for</span>(i=0; i&lt;NUM_ROWS*NUM_COLS; i++) {
        *(<span style="font-weight: bold">uint8_t</span> *)(video_mem + (i &lt;&lt; 1)) = <span style="font-style: italic">&#39; &#39;</span>;
        *(<span style="font-weight: bold">uint8_t</span> *)(video_mem + (i &lt;&lt; 1) + 1) = ATTRIB;
    }
}

<span style="font-style: italic">/* Standard printf().</span>
<span style="font-style: italic"> * Only supports the following format strings:</span>
<span style="font-style: italic"> * %%  - print a literal &#39;%&#39; character</span>
<span style="font-style: italic"> * %x  - print a number in hexadecimal</span>
<span style="font-style: italic"> * %u  - print a number as an unsigned integer</span>
<span style="font-style: italic"> * %d  - print a number as a signed integer</span>
<span style="font-style: italic"> * %c  - print a character</span>
<span style="font-style: italic"> * %s  - print a string</span>
<span style="font-style: italic"> * %#x - print a number in 32-bit aligned hexadecimal, i.e.</span>
<span style="font-style: italic"> *       print 8 hexadecimal digits, zero-padded on the left.</span>
<span style="font-style: italic"> *       For example, the hex number &quot;E&quot; would be printed as</span>
<span style="font-style: italic"> *       &quot;0000000E&quot;.</span>
<span style="font-style: italic"> *       Note: This is slightly different than the libc specification</span>
<span style="font-style: italic"> *       for the &quot;#&quot; modifier (this implementation doesn&#39;t add a &quot;0x&quot; at</span>
<span style="font-style: italic"> *       the beginning), but I think it&#39;s more flexible this way.</span>
<span style="font-style: italic"> *       Also note: %x is the only conversion specifier that can use</span>
<span style="font-style: italic"> *       the &quot;#&quot; modifier to alter output.</span>
<span style="font-style: italic"> * */</span>
<span style="font-weight: bold">int32_t</span>
printf(<span style="font-weight: bold">int8_t</span> *format, ...)
{
	<span style="font-style: italic">/* Pointer to the format string */</span>
	<span style="font-weight: bold">int8_t</span>* buf = format;

	<span style="font-style: italic">/* Stack pointer for the other parameters */</span>
	<span style="font-weight: bold">int32_t</span>* esp = (<span style="font-weight: bold">void</span> *)&amp;format;
	esp++;

	<span style="font-weight: bold">while</span>(*buf != <span style="font-style: italic">&#39;\0&#39;</span>) {
		<span style="font-weight: bold">switch</span>(*buf) {
			<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;%&#39;</span>:
				{
					<span style="font-weight: bold">int32_t</span> alternate = 0;
					buf++;

format_char_switch:
					<span style="font-style: italic">/* Conversion specifiers */</span>
					<span style="font-weight: bold">switch</span>(*buf) {
						<span style="font-style: italic">/* Print a literal &#39;%&#39; character */</span>
						<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;%&#39;</span>:
							putc(<span style="font-style: italic">&#39;%&#39;</span>);
							<span style="font-weight: bold">break</span>;

						<span style="font-style: italic">/* Use alternate formatting */</span>
						<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;#&#39;</span>:
							alternate = 1;
							buf++;
							<span style="font-style: italic">/* Yes, I know gotos are bad.  This is the</span>
<span style="font-style: italic">							 * most elegant and general way to do this,</span>
<span style="font-style: italic">							 * IMHO. */</span>
							<span style="font-weight: bold">goto</span> format_char_switch;

						<span style="font-style: italic">/* Print a number in hexadecimal form */</span>
						<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;x&#39;</span>:
							{
								<span style="font-weight: bold">int8_t</span> conv_buf[64];
								<span style="font-weight: bold">if</span>(alternate == 0) {
									itoa(*((<span style="font-weight: bold">uint32_t</span> *)esp), conv_buf, 16);
									puts(conv_buf);
								} <span style="font-weight: bold">else</span> {
									<span style="font-weight: bold">int32_t</span> starting_index;
									<span style="font-weight: bold">int32_t</span> i;
									itoa(*((<span style="font-weight: bold">uint32_t</span> *)esp), &amp;conv_buf[8], 16);
									i = starting_index = strlen(&amp;conv_buf[8]);
									<span style="font-weight: bold">while</span>(i &lt; 8) {
										conv_buf[i] = <span style="font-style: italic">&#39;0&#39;</span>;
										i++;
									}
									puts(&amp;conv_buf[starting_index]);
								}
								esp++;
							}
							<span style="font-weight: bold">break</span>;

						<span style="font-style: italic">/* Print a number in unsigned int form */</span>
						<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;u&#39;</span>:
							{
								<span style="font-weight: bold">int8_t</span> conv_buf[36];
								itoa(*((<span style="font-weight: bold">uint32_t</span> *)esp), conv_buf, 10);
								puts(conv_buf);
								esp++;
							}
							<span style="font-weight: bold">break</span>;

						<span style="font-style: italic">/* Print a number in signed int form */</span>
						<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;d&#39;</span>:
							{
								<span style="font-weight: bold">int8_t</span> conv_buf[36];
								<span style="font-weight: bold">int32_t</span> value = *((<span style="font-weight: bold">int32_t</span> *)esp);
								<span style="font-weight: bold">if</span>(value &lt; 0) {
									conv_buf[0] = <span style="font-style: italic">&#39;-&#39;</span>;
									itoa(-value, &amp;conv_buf[1], 10);
								} <span style="font-weight: bold">else</span> {
									itoa(value, conv_buf, 10);
								}
								puts(conv_buf);
								esp++;
							}
							<span style="font-weight: bold">break</span>;

						<span style="font-style: italic">/* Print a single character */</span>
						<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;c&#39;</span>:
							putc( (<span style="font-weight: bold">uint8_t</span>) *((<span style="font-weight: bold">int32_t</span> *)esp) );
							esp++;
							<span style="font-weight: bold">break</span>;

						<span style="font-style: italic">/* Print a NULL-terminated string */</span>
						<span style="font-weight: bold">case</span> <span style="font-style: italic">&#39;s&#39;</span>:
							puts( *((<span style="font-weight: bold">int8_t</span> **)esp) );
							esp++;
							<span style="font-weight: bold">break</span>;

						default:
							<span style="font-weight: bold">break</span>;
					}

				}
				<span style="font-weight: bold">break</span>;

			default:
				putc(*buf);
				<span style="font-weight: bold">break</span>;
		}
		buf++;
	}

	<span style="font-weight: bold">return</span> (buf - format);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* int32_t puts(int8_t* s);</span>
<span style="font-style: italic">*   Inputs: int_8* s = pointer to a string of characters</span>
<span style="font-style: italic">*   Return Value: Number of bytes written</span>
<span style="font-style: italic">*	Function: Output a string to the console </span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">int32_t</span>
puts(<span style="font-weight: bold">int8_t</span>* s)
{
	<span style="font-weight: bold">register</span> <span style="font-weight: bold">int32_t</span> index = 0;
	<span style="font-weight: bold">while</span>(s[index] != <span style="font-style: italic">&#39;\0&#39;</span>) {
		putc(s[index]);
		index++;
	}

	<span style="font-weight: bold">return</span> index;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void putc(uint8_t c);</span>
<span style="font-style: italic">*   Inputs: uint_8* c = character to print</span>
<span style="font-style: italic">*   Return Value: void</span>
<span style="font-style: italic">*	Function: Output a character to the console </span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">void</span>
putc(<span style="font-weight: bold">uint8_t</span> c)
{
    <span style="font-weight: bold">if</span>(c == <span style="font-style: italic">&#39;\n&#39;</span> || c == <span style="font-style: italic">&#39;\r&#39;</span>) {
        screen_y++;
        screen_x=0;
    } <span style="font-weight: bold">else</span> {
        *(<span style="font-weight: bold">uint8_t</span> *)(video_mem + ((NUM_COLS*screen_y + screen_x) &lt;&lt; 1)) = c;
        *(<span style="font-weight: bold">uint8_t</span> *)(video_mem + ((NUM_COLS*screen_y + screen_x) &lt;&lt; 1) + 1) = ATTRIB;
        screen_x++;
        screen_x %= NUM_COLS;
        screen_y = (screen_y + (screen_x / NUM_COLS)) % NUM_ROWS;
    }
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* int8_t* itoa(uint32_t value, int8_t* buf, int32_t radix);</span>
<span style="font-style: italic">*   Inputs: uint32_t value = number to convert</span>
<span style="font-style: italic">*			int8_t* buf = allocated buffer to place string in</span>
<span style="font-style: italic">*			int32_t radix = base system. hex, oct, dec, etc.</span>
<span style="font-style: italic">*   Return Value: number of bytes written</span>
<span style="font-style: italic">*	Function: Convert a number to its ASCII representation, with base &quot;radix&quot;</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">int8_t</span>*
itoa(<span style="font-weight: bold">uint32_t</span> value, <span style="font-weight: bold">int8_t</span>* buf, <span style="font-weight: bold">int32_t</span> radix)
{
	<span style="font-weight: bold">static</span> <span style="font-weight: bold">int8_t</span> lookup[] = <span style="font-style: italic">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;

	<span style="font-weight: bold">int8_t</span> *newbuf = buf;
	<span style="font-weight: bold">int32_t</span> i;
	<span style="font-weight: bold">uint32_t</span> newval = value;

	<span style="font-style: italic">/* Special case for zero */</span>
	<span style="font-weight: bold">if</span>(value == 0) {
		buf[0]=<span style="font-style: italic">&#39;0&#39;</span>;
		buf[1]=<span style="font-style: italic">&#39;\0&#39;</span>;
		<span style="font-weight: bold">return</span> buf;
	}

	<span style="font-style: italic">/* Go through the number one place value at a time, and add the</span>
<span style="font-style: italic">	 * correct digit to &quot;newbuf&quot;.  We actually add characters to the</span>
<span style="font-style: italic">	 * ASCII string from lowest place value to highest, which is the</span>
<span style="font-style: italic">	 * opposite of how the number should be printed.  We&#39;ll reverse the</span>
<span style="font-style: italic">	 * characters later. */</span>
	<span style="font-weight: bold">while</span>(newval &gt; 0) {
		i = newval % radix;
		*newbuf = lookup[i];
		newbuf++;
		newval /= radix;
	}

	<span style="font-style: italic">/* Add a terminating NULL */</span>
	*newbuf = <span style="font-style: italic">&#39;\0&#39;</span>;

	<span style="font-style: italic">/* Reverse the string and return */</span>
	<span style="font-weight: bold">return</span> strrev(buf);
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* int8_t* strrev(int8_t* s);</span>
<span style="font-style: italic">*   Inputs: int8_t* s = string to reverse</span>
<span style="font-style: italic">*   Return Value: reversed string</span>
<span style="font-style: italic">*	Function: reverses a string s</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">int8_t</span>*
strrev(<span style="font-weight: bold">int8_t</span>* s)
{
	<span style="font-weight: bold">register</span> <span style="font-weight: bold">int8_t</span> tmp;
	<span style="font-weight: bold">register</span> <span style="font-weight: bold">int32_t</span> beg=0;
	<span style="font-weight: bold">register</span> <span style="font-weight: bold">int32_t</span> end=strlen(s) - 1;

	<span style="font-weight: bold">while</span>(beg &lt; end) {
		tmp = s[end];
		s[end] = s[beg];
		s[beg] = tmp;
		beg++;
		end--;
	}

	<span style="font-weight: bold">return</span> s;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* uint32_t strlen(const int8_t* s);</span>
<span style="font-style: italic">*   Inputs: const int8_t* s = string to take length of</span>
<span style="font-style: italic">*   Return Value: length of string s</span>
<span style="font-style: italic">*	Function: return length of string s</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">uint32_t</span>
strlen(<span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* s)
{
	<span style="font-weight: bold">register</span> <span style="font-weight: bold">uint32_t</span> len = 0;
	<span style="font-weight: bold">while</span>(s[len] != <span style="font-style: italic">&#39;\0&#39;</span>)
		len++;

	<span style="font-weight: bold">return</span> len;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void* memset(void* s, int32_t c, uint32_t n);</span>
<span style="font-style: italic">*   Inputs: void* s = pointer to memory</span>
<span style="font-style: italic">*			int32_t c = value to set memory to</span>
<span style="font-style: italic">*			uint32_t n = number of bytes to set</span>
<span style="font-style: italic">*   Return Value: new string</span>
<span style="font-style: italic">*	Function: set n consecutive bytes of pointer s to value c</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">void</span>*
memset(<span style="font-weight: bold">void</span>* s, <span style="font-weight: bold">int32_t</span> c, <span style="font-weight: bold">uint32_t</span> n)
{
	c &amp;= 0xFF;
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;                  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memset_top:            </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			testl   %%ecx, %%ecx    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jz      .memset_done    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			testl   $0x3, %%edi     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jz      .memset_aligned </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movb    %%al, (%%edi)   </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			addl    $1, %%edi       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			subl    $1, %%ecx       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jmp     .memset_top     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memset_aligned:        </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%ds, %%dx      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%dx, %%es      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movl    %%ecx, %%edx    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			shrl    $2, %%ecx       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			andl    $0x3, %%edx     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			cld                     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			rep     stosl           </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memset_bottom:         </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			testl   %%edx, %%edx    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jz      .memset_done    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movb    %%al, (%%edi)   </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			addl    $1, %%edi       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			subl    $1, %%edx       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jmp     .memset_bottom  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memset_done:           </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			&quot;</span>
			:
			: <span style="font-style: italic">&quot;a&quot;</span>(c &lt;&lt; 24 | c &lt;&lt; 16 | c &lt;&lt; 8 | c), <span style="font-style: italic">&quot;D&quot;</span>(s), <span style="font-style: italic">&quot;c&quot;</span>(n)
			: <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
			);

	<span style="font-weight: bold">return</span> s;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void* memset_word(void* s, int32_t c, uint32_t n);</span>
<span style="font-style: italic">*   Inputs: void* s = pointer to memory</span>
<span style="font-style: italic">*			int32_t c = value to set memory to</span>
<span style="font-style: italic">*			uint32_t n = number of bytes to set</span>
<span style="font-style: italic">*   Return Value: new string</span>
<span style="font-style: italic">*	Function: set lower 16 bits of n consecutive memory locations of pointer s to value c</span>
<span style="font-style: italic">*/</span>

<span style="font-style: italic">/* Optimized memset_word */</span>
<span style="font-weight: bold">void</span>*
memset_word(<span style="font-weight: bold">void</span>* s, <span style="font-weight: bold">int32_t</span> c, <span style="font-weight: bold">uint32_t</span> n)
{
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;                  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%ds, %%dx      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%dx, %%es      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			cld                     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			rep     stosw           </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			&quot;</span>
			:
			: <span style="font-style: italic">&quot;a&quot;</span>(c), <span style="font-style: italic">&quot;D&quot;</span>(s), <span style="font-style: italic">&quot;c&quot;</span>(n)
			: <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
			);

	<span style="font-weight: bold">return</span> s;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void* memset_dword(void* s, int32_t c, uint32_t n);</span>
<span style="font-style: italic">*   Inputs: void* s = pointer to memory</span>
<span style="font-style: italic">*			int32_t c = value to set memory to</span>
<span style="font-style: italic">*			uint32_t n = number of bytes to set</span>
<span style="font-style: italic">*   Return Value: new string</span>
<span style="font-style: italic">*	Function: set n consecutive memory locations of pointer s to value c</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">void</span>*
memset_dword(<span style="font-weight: bold">void</span>* s, <span style="font-weight: bold">int32_t</span> c, <span style="font-weight: bold">uint32_t</span> n)
{
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;                  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%ds, %%dx      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%dx, %%es      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			cld                     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			rep     stosl           </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			&quot;</span>
			:
			: <span style="font-style: italic">&quot;a&quot;</span>(c), <span style="font-style: italic">&quot;D&quot;</span>(s), <span style="font-style: italic">&quot;c&quot;</span>(n)
			: <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
			);

	<span style="font-weight: bold">return</span> s;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void* memcpy(void* dest, const void* src, uint32_t n);</span>
<span style="font-style: italic">*   Inputs: void* dest = destination of copy</span>
<span style="font-style: italic">*			const void* src = source of copy</span>
<span style="font-style: italic">*			uint32_t n = number of byets to copy</span>
<span style="font-style: italic">*   Return Value: pointer to dest</span>
<span style="font-style: italic">*	Function: copy n bytes of src to dest</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">void</span>*
memcpy(<span style="font-weight: bold">void</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* src, <span style="font-weight: bold">uint32_t</span> n)
{
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;                  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memcpy_top:            </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			testl   %%ecx, %%ecx    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jz      .memcpy_done    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			testl   $0x3, %%edi     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jz      .memcpy_aligned </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movb    (%%esi), %%al   </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movb    %%al, (%%edi)   </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			addl    $1, %%edi       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			addl    $1, %%esi       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			subl    $1, %%ecx       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jmp     .memcpy_top     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memcpy_aligned:        </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%ds, %%dx      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%dx, %%es      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movl    %%ecx, %%edx    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			shrl    $2, %%ecx       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			andl    $0x3, %%edx     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			cld                     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			rep     movsl           </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memcpy_bottom:         </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			testl   %%edx, %%edx    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jz      .memcpy_done    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movb    (%%esi), %%al   </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movb    %%al, (%%edi)   </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			addl    $1, %%edi       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			addl    $1, %%esi       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			subl    $1, %%edx       </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jmp     .memcpy_bottom  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memcpy_done:           </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			&quot;</span>
			:
			: <span style="font-style: italic">&quot;S&quot;</span>(src), <span style="font-style: italic">&quot;D&quot;</span>(dest), <span style="font-style: italic">&quot;c&quot;</span>(n)
			: <span style="font-style: italic">&quot;eax&quot;</span>, <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
			);

	<span style="font-weight: bold">return</span> dest;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void* memmove(void* dest, const void* src, uint32_t n);</span>
<span style="font-style: italic">*   Inputs: void* dest = destination of move</span>
<span style="font-style: italic">*			const void* src = source of move</span>
<span style="font-style: italic">*			uint32_t n = number of byets to move</span>
<span style="font-style: italic">*   Return Value: pointer to dest</span>
<span style="font-style: italic">*	Function: move n bytes of src to dest</span>
<span style="font-style: italic">*/</span>

<span style="font-style: italic">/* Optimized memmove (used for overlapping memory areas) */</span>
<span style="font-weight: bold">void</span>*
memmove(<span style="font-weight: bold">void</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* src, <span style="font-weight: bold">uint32_t</span> n)
{
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;                  </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%ds, %%dx      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			movw    %%dx, %%es      </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			cld                     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			cmp     %%edi, %%esi    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			jae     .memmove_go     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			leal    -1(%%esi, %%ecx), %%esi    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			leal    -1(%%edi, %%ecx), %%edi    </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			std                     </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			.memmove_go:            </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			rep     movsb           </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">			&quot;</span>
			:
			: <span style="font-style: italic">&quot;D&quot;</span>(dest), <span style="font-style: italic">&quot;S&quot;</span>(src), <span style="font-style: italic">&quot;c&quot;</span>(n)
			: <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
			);

	<span style="font-weight: bold">return</span> dest;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* int32_t strncmp(const int8_t* s1, const int8_t* s2, uint32_t n)</span>
<span style="font-style: italic">*   Inputs: const int8_t* s1 = first string to compare</span>
<span style="font-style: italic">*			const int8_t* s2 = second string to compare</span>
<span style="font-style: italic">*			uint32_t n = number of bytes to compare</span>
<span style="font-style: italic">*	Return Value: A zero value indicates that the characters compared </span>
<span style="font-style: italic">*					in both strings form the same string.</span>
<span style="font-style: italic">*				A value greater than zero indicates that the first </span>
<span style="font-style: italic">*					character that does not match has a greater value </span>
<span style="font-style: italic">*					in str1 than in str2; And a value less than zero </span>
<span style="font-style: italic">*					indicates the opposite.</span>
<span style="font-style: italic">*	Function: compares string 1 and string 2 for equality</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">int32_t</span>
strncmp(<span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* s1, <span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* s2, <span style="font-weight: bold">uint32_t</span> n)
{
	<span style="font-weight: bold">int32_t</span> i;
	<span style="font-weight: bold">for</span>(i=0; i&lt;n; i++) {
		<span style="font-weight: bold">if</span>( (s1[i] != s2[i]) ||
				(s1[i] == <span style="font-style: italic">&#39;\0&#39;</span>) <span style="font-style: italic">/* || s2[i] == &#39;\0&#39; */</span> ) {

			<span style="font-style: italic">/* The s2[i] == &#39;\0&#39; is unnecessary because of the short-circuit</span>
<span style="font-style: italic">			 * semantics of &#39;if&#39; expressions in C.  If the first expression</span>
<span style="font-style: italic">			 * (s1[i] != s2[i]) evaluates to false, that is, if s1[i] ==</span>
<span style="font-style: italic">			 * s2[i], then we only need to test either s1[i] or s2[i] for</span>
<span style="font-style: italic">			 * &#39;\0&#39;, since we know they are equal. */</span>

			<span style="font-weight: bold">return</span> s1[i] - s2[i];
		}
	}
	<span style="font-weight: bold">return</span> 0;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* int8_t* strcpy(int8_t* dest, const int8_t* src)</span>
<span style="font-style: italic">*   Inputs: int8_t* dest = destination string of copy</span>
<span style="font-style: italic">*			const int8_t* src = source string of copy</span>
<span style="font-style: italic">*   Return Value: pointer to dest</span>
<span style="font-style: italic">*	Function: copy the source string into the destination string</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">int8_t</span>*
strcpy(<span style="font-weight: bold">int8_t</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* src)
{
	<span style="font-weight: bold">int32_t</span> i=0;
	<span style="font-weight: bold">while</span>(src[i] != <span style="font-style: italic">&#39;\0&#39;</span>) {
		dest[i] = src[i];
		i++;
	}

	dest[i] = <span style="font-style: italic">&#39;\0&#39;</span>;
	<span style="font-weight: bold">return</span> dest;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* int8_t* strcpy(int8_t* dest, const int8_t* src, uint32_t n)</span>
<span style="font-style: italic">*   Inputs: int8_t* dest = destination string of copy</span>
<span style="font-style: italic">*			const int8_t* src = source string of copy</span>
<span style="font-style: italic">*			uint32_t n = number of bytes to copy</span>
<span style="font-style: italic">*   Return Value: pointer to dest</span>
<span style="font-style: italic">*	Function: copy n bytes of the source string into the destination string</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">int8_t</span>*
strncpy(<span style="font-weight: bold">int8_t</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* src, <span style="font-weight: bold">uint32_t</span> n)
{
	<span style="font-weight: bold">int32_t</span> i=0;
	<span style="font-weight: bold">while</span>(src[i] != <span style="font-style: italic">&#39;\0&#39;</span> &amp;&amp; i &lt; n) {
		dest[i] = src[i];
		i++;
	}

	<span style="font-weight: bold">while</span>(i &lt; n) {
		dest[i] = <span style="font-style: italic">&#39;\0&#39;</span>;
		i++;
	}

	<span style="font-weight: bold">return</span> dest;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic">* void test_interrupts(void)</span>
<span style="font-style: italic">*   Inputs: void</span>
<span style="font-style: italic">*   Return Value: void</span>
<span style="font-style: italic">*	Function: increments video memory. To be used to test rtc</span>
<span style="font-style: italic">*/</span>

<span style="font-weight: bold">void</span>
test_interrupts(<span style="font-weight: bold">void</span>)
{
	<span style="font-weight: bold">int32_t</span> i;
	<span style="font-weight: bold">for</span> (i=0; i &lt; NUM_ROWS*NUM_COLS; i++) {
		video_mem[i&lt;&lt;1]++;
	}
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--lib.h-->
        <section>
            <hnew id="lib.h">lib.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">/* lib.h - Defines for useful library functions</span>
<span style="font-style: italic"> * vim:ts=4 noexpandtab</span>
<span style="font-style: italic"> */</span>

<span style="font-style: italic">#ifndef _LIB_H</span>
<span style="font-style: italic">#define _LIB_H</span>

<span style="font-style: italic">#include &quot;types.h&quot;</span>

<span style="font-weight: bold">int32_t</span> printf(<span style="font-weight: bold">int8_t</span> *format, ...);
<span style="font-weight: bold">void</span> putc(<span style="font-weight: bold">uint8_t</span> c);
<span style="font-weight: bold">int32_t</span> puts(<span style="font-weight: bold">int8_t</span> *s);
<span style="font-weight: bold">int8_t</span> *itoa(<span style="font-weight: bold">uint32_t</span> value, <span style="font-weight: bold">int8_t</span>* buf, <span style="font-weight: bold">int32_t</span> radix);
<span style="font-weight: bold">int8_t</span> *strrev(<span style="font-weight: bold">int8_t</span>* s);
<span style="font-weight: bold">uint32_t</span> strlen(<span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* s);
<span style="font-weight: bold">void</span> clear(<span style="font-weight: bold">void</span>);

<span style="font-weight: bold">void</span>* memset(<span style="font-weight: bold">void</span>* s, <span style="font-weight: bold">int32_t</span> c, <span style="font-weight: bold">uint32_t</span> n);
<span style="font-weight: bold">void</span>* memset_word(<span style="font-weight: bold">void</span>* s, <span style="font-weight: bold">int32_t</span> c, <span style="font-weight: bold">uint32_t</span> n);
<span style="font-weight: bold">void</span>* memset_dword(<span style="font-weight: bold">void</span>* s, <span style="font-weight: bold">int32_t</span> c, <span style="font-weight: bold">uint32_t</span> n);
<span style="font-weight: bold">void</span>* memcpy(<span style="font-weight: bold">void</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* src, <span style="font-weight: bold">uint32_t</span> n);
<span style="font-weight: bold">void</span>* memmove(<span style="font-weight: bold">void</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* src, <span style="font-weight: bold">uint32_t</span> n);
<span style="font-weight: bold">int32_t</span> strncmp(<span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* s1, <span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* s2, <span style="font-weight: bold">uint32_t</span> n);
<span style="font-weight: bold">int8_t</span>* strcpy(<span style="font-weight: bold">int8_t</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>*src);
<span style="font-weight: bold">int8_t</span>* strncpy(<span style="font-weight: bold">int8_t</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>*src, <span style="font-weight: bold">uint32_t</span> n);

<span style="font-style: italic">/* Userspace address-check functions */</span>
<span style="font-weight: bold">int32_t</span> bad_userspace_addr(<span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* addr, <span style="font-weight: bold">int32_t</span> len);
<span style="font-weight: bold">int32_t</span> safe_strncpy(<span style="font-weight: bold">int8_t</span>* dest, <span style="font-weight: bold">const</span> <span style="font-weight: bold">int8_t</span>* src, <span style="font-weight: bold">int32_t</span> n);

<span style="font-style: italic">/* Port read functions */</span>
<span style="font-style: italic">/* Inb reads a byte and returns its value as a zero-extended 32-bit</span>
<span style="font-style: italic"> * unsigned int */</span>
<span style="font-weight: bold">static</span> <span style="font-weight: bold">inline</span> <span style="font-weight: bold">uint32_t</span> inb(port)
{
	<span style="font-weight: bold">uint32_t</span> val;
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;xorl %0, %0</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic"> \</span>
<span style="font-style: italic">			inb   (%w1), %b0&quot;</span> 
			: <span style="font-style: italic">&quot;=a&quot;</span>(val)
			: <span style="font-style: italic">&quot;d&quot;</span>(port)
			: <span style="font-style: italic">&quot;memory&quot;</span> );
	<span style="font-weight: bold">return</span> val;
} 

<span style="font-style: italic">/* Reads two bytes from two consecutive ports, starting at &quot;port&quot;,</span>
<span style="font-style: italic"> * concatenates them little-endian style, and returns them zero-extended</span>
<span style="font-style: italic"> * */</span>
<span style="font-weight: bold">static</span> <span style="font-weight: bold">inline</span> <span style="font-weight: bold">uint32_t</span> inw(port)
{
	<span style="font-weight: bold">uint32_t</span> val;
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;xorl %0, %0</span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">   \</span>
<span style="font-style: italic">			inw   (%w1), %w0&quot;</span>
			: <span style="font-style: italic">&quot;=a&quot;</span>(val)
			: <span style="font-style: italic">&quot;d&quot;</span>(port)
			: <span style="font-style: italic">&quot;memory&quot;</span> );
	<span style="font-weight: bold">return</span> val;
}

<span style="font-style: italic">/* Reads four bytes from four consecutive ports, starting at &quot;port&quot;,</span>
<span style="font-style: italic"> * concatenates them little-endian style, and returns them */</span>
<span style="font-weight: bold">static</span> <span style="font-weight: bold">inline</span> <span style="font-weight: bold">uint32_t</span> inl(port)
{
	<span style="font-weight: bold">uint32_t</span> val;
	asm <span style="font-weight: bold">volatile</span>(<span style="font-style: italic">&quot;inl   (%w1), %0&quot;</span>
			: <span style="font-style: italic">&quot;=a&quot;</span>(val)
			: <span style="font-style: italic">&quot;d&quot;</span>(port)
			: <span style="font-style: italic">&quot;memory&quot;</span> );
	<span style="font-weight: bold">return</span> val;
}

<span style="font-style: italic">/* Writes a byte to a port */</span>
<span style="font-style: italic">#define outb(data, port)                \</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot;outb  %b1, (%w0)&quot;     \</span>
<span style="font-style: italic">			:                           \</span>
<span style="font-style: italic">			: &quot;d&quot; (port), &quot;a&quot; (data)    \</span>
<span style="font-style: italic">			: &quot;memory&quot;, &quot;cc&quot; );         \</span>
<span style="font-style: italic">} while(0)</span>

<span style="font-style: italic">/* Writes two bytes to two consecutive ports */</span>
<span style="font-style: italic">#define outw(data, port)                \</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot;outw  %w1, (%w0)&quot;     \</span>
<span style="font-style: italic">			:                           \</span>
<span style="font-style: italic">			: &quot;d&quot; (port), &quot;a&quot; (data)    \</span>
<span style="font-style: italic">			: &quot;memory&quot;, &quot;cc&quot; );         \</span>
<span style="font-style: italic">} while(0)</span>

<span style="font-style: italic">/* Writes four bytes to four consecutive ports */</span>
<span style="font-style: italic">#define outl(data, port)                \</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot;outl  %l1, (%w0)&quot;     \</span>
<span style="font-style: italic">			:                           \</span>
<span style="font-style: italic">			: &quot;d&quot; (port), &quot;a&quot; (data)    \</span>
<span style="font-style: italic">			: &quot;memory&quot;, &quot;cc&quot; );         \</span>
<span style="font-style: italic">} while(0)</span>

<span style="font-style: italic">/* Clear interrupt flag - disables interrupts on this processor */</span>
<span style="font-style: italic">#define cli()                           \</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot;cli&quot;                  \</span>
<span style="font-style: italic">			:                       \</span>
<span style="font-style: italic">			:                       \</span>
<span style="font-style: italic">			: &quot;memory&quot;, &quot;cc&quot;        \</span>
<span style="font-style: italic">			);                      \</span>
<span style="font-style: italic">} while(0)</span>

<span style="font-style: italic">/* Save flags and then clear interrupt flag</span>
<span style="font-style: italic"> * Saves the EFLAGS register into the variable &quot;flags&quot;, and then</span>
<span style="font-style: italic"> * disables interrupts on this processor */</span>
<span style="font-style: italic">#define cli_and_save(flags)             \</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot;pushfl        \n      \</span>
<span style="font-style: italic">			popl %0         \n      \</span>
<span style="font-style: italic">			cli&quot;                    \</span>
<span style="font-style: italic">			: &quot;=r&quot;(flags)           \</span>
<span style="font-style: italic">			:                       \</span>
<span style="font-style: italic">			: &quot;memory&quot;, &quot;cc&quot;        \</span>
<span style="font-style: italic">			);                      \</span>
<span style="font-style: italic">} while(0)</span>

<span style="font-style: italic">/* Set interrupt flag - enable interrupts on this processor */</span>
<span style="font-style: italic">#define sti()                           \</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot;sti&quot;                  \</span>
<span style="font-style: italic">			:                       \</span>
<span style="font-style: italic">			:                       \</span>
<span style="font-style: italic">			: &quot;memory&quot;, &quot;cc&quot;        \</span>
<span style="font-style: italic">			);                      \</span>
<span style="font-style: italic">} while(0)</span>

<span style="font-style: italic">/* Restore flags</span>
<span style="font-style: italic"> * Puts the value in &quot;flags&quot; into the EFLAGS register.  Most often used</span>
<span style="font-style: italic"> * after a cli_and_save_flags(flags) */</span>
<span style="font-style: italic">#define restore_flags(flags)            \</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot;pushl %0      \n      \</span>
<span style="font-style: italic">			popfl&quot;                  \</span>
<span style="font-style: italic">			:                       \</span>
<span style="font-style: italic">			: &quot;r&quot;(flags)            \</span>
<span style="font-style: italic">			: &quot;memory&quot;, &quot;cc&quot;        \</span>
<span style="font-style: italic">			);                      \</span>
<span style="font-style: italic">} while(0)</span>

<span style="font-style: italic">#endif /* _LIB_H */</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--paging.c-->
        <section>
            <hnew id="paging.c">paging.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#include &quot;paging.h&quot;</span>
<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     init_paging</span>
<span style="font-style: italic"> *Description:  initializes paging, that is creates a page directory with 1024 entries, a page table with 1024 entries and  </span>
<span style="font-style: italic"> *                initializes the 1024 pages</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> init_paging ()
{
	<span style="font-weight: bold">int</span> i;
	<span style="font-weight: bold">for</span> (i = 0; i &lt; PAGE_DIR_SIZE; i++) { <span style="font-style: italic">//initialize the page directory</span>
		page_directory[i] = PAGE_DIR_INIT_ENTRY; <span style="font-style: italic">//set read/write flag, but not present</span>
	}

	<span style="font-weight: bold">for</span> (i = 0; i &lt; PAGE_TABLE_SIZE; i++) { <span style="font-style: italic">//initialize the page table</span>
		first_4_MB_page[i] = (i &lt;&lt; SHIFT_i) | MASK_HEX_TWO; <span style="font-style: italic">//set the read/write flag</span>
	}
	first_4_MB_page[IDX_VID_MEM_START] = (VIDEO_MEMORY_START_ADDR) | MASK_HEX_THREE; <span style="font-style: italic">// mark video memory page as present  </span>

	page_directory[0] = ((<span style="font-weight: bold">uint32_t</span>) first_4_MB_page) | MASK_HEX_ZERO_THREE; 
	page_directory[1] = (<span style="font-weight: bold">uint32_t</span>) (KERNEL_PAGE_ADDR | RW_P_VALUE); <span style="font-style: italic">//4 MB page, read/write, and presence of kernel page</span>

	load_page_directory ((<span style="font-weight: bold">uint32_t</span>) page_directory); <span style="font-style: italic">// set PDBR register to hold page directory starting address</span>
	enable_paging (); <span style="font-style: italic">//change paging flag to enable</span>

}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     init_paging_user_program</span>
<span style="font-style: italic"> *Description:  sets pages for the user program to use</span>
<span style="font-style: italic"> *Input:        base address for program image, pointer to program control block</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
 <span style="font-weight: bold">void</span> init_paging_user_program (<span style="font-weight: bold">uint32_t</span> physical_adress_program_big_page, <span style="font-weight: bold">uint32_t</span> child_pcb)
{
	page_directory[physical_adress_program_big_page / LARGE_PAGE_SIZE] = (<span style="font-weight: bold">uint32_t</span>) (physical_adress_program_big_page  | S_U_R_FLAGS); <span style="font-style: italic">//4 MB page, read/write, and presence of kernel page</span>

	<span style="font-weight: bold">program_control_block_t</span> * new_child_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) child_pcb;
	<span style="font-style: italic">//#define USER_PROGRAM_VM_LOC 128 * 1024 * 1024</span>
	<span style="font-weight: bold">int</span> i;

	<span style="font-style: italic">//new_child_pcb = (program_control_block_t *) get_pcb_of_cur_process();</span>
	new_child_pcb-&gt;pg_dir_table = &amp;user_page_directories [new_child_pcb-&gt;pid * PAGE_DIR_SIZE];
	cli();

	<span style="font-style: italic">/* video memory page and kernel can be left as is */</span>
	
	<span style="font-weight: bold">for</span> (i = 0; i &lt; PAGE_DIR_SIZE; i++) { <span style="font-style: italic">//initialize the page directory</span>
		new_child_pcb-&gt;pg_dir_table[i] = PAGE_DIR_INIT_ENTRY; <span style="font-style: italic">//set read/write flag, but not present</span>
	}

	new_child_pcb-&gt;pg_dir_table[0] = ((<span style="font-weight: bold">uint32_t</span>) first_4_MB_page) | MASK_HEX_ZERO_THREE;

	new_child_pcb-&gt;pg_dir_table[1] = (<span style="font-weight: bold">uint32_t</span>) (KERNEL_PAGE_ADDR | RW_P_VALUE); <span style="font-style: italic">//4 MB page, read/write, and presence of kernel page</span>

	new_child_pcb-&gt;pg_dir_table[PROGRAM_4MB_PAGE_OFFSET] = (<span style="font-weight: bold">uint32_t</span>) (physical_adress_program_big_page | S_U_R_FLAGS); <span style="font-style: italic">//4 MB page, read/write, and presence of page</span>

	new_child_pcb-&gt;pg_dir_table[BACKPAGE_PG_ENTRY_IDX] = (<span style="font-weight: bold">uint32_t</span>) (PHYS_ADDR_VIDEO_BACK_PAGES | S_U_R_FLAGS); <span style="font-style: italic">//4 MB page, read/write, and presence of page</span>

	new_child_pcb-&gt;cr3 = (<span style="font-weight: bold">uint32_t</span>) new_child_pcb-&gt;pg_dir_table;
	
	load_page_directory ((<span style="font-weight: bold">uint32_t</span>) new_child_pcb-&gt;pg_dir_table); <span style="font-style: italic">// set PDBR register to hold page directory starting address</span>
	sti();
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     load_page_directory</span>
<span style="font-style: italic"> *Description:  loads each page directory entry</span>
<span style="font-style: italic"> *Input:        page_directory_addr: the address of the page directory entry to load</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>

<span style="font-weight: bold">void</span> load_page_directory (<span style="font-weight: bold">uint32_t</span> page_directory_addr)
{
	asm <span style="font-weight: bold">volatile</span>(
				<span style="font-style: italic">&quot; movl %0, %%edx ;&quot;</span>
				<span style="font-style: italic">&quot; movl %%edx, %%cr3 ;&quot;</span>
			:
			: <span style="font-style: italic">&quot;r&quot;</span>(page_directory_addr)
			: <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
			);

}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> *Function:     enable_paging</span>
<span style="font-style: italic"> *Description:  enables the initalization of the paging</span>
<span style="font-style: italic"> *Input:        none</span>
<span style="font-style: italic"> *Output:       none</span>
<span style="font-style: italic"> *Return value: none</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> enable_paging ()
{
	asm <span style="font-weight: bold">volatile</span> (
			<span style="font-style: italic">&quot;movl %%cr4, %%eax ;&quot;</span>
			<span style="font-style: italic">&quot;orl $0x00000010, %%eax ;&quot;</span> <span style="font-style: italic">// enable 4 mb pages</span>
			<span style="font-style: italic">&quot;movl %%eax, %%cr4 ;&quot;</span> 
			<span style="font-style: italic">&quot;movl %%cr0, %%eax ;&quot;</span>
			<span style="font-style: italic">&quot;orl $0x80000000, %%eax ;&quot;</span> <span style="font-style: italic">//set paging enable bit</span>
			<span style="font-style: italic">&quot;movl %%eax, %%cr0 ;&quot;</span>
			:
			: 
			: <span style="font-style: italic">&quot;eax&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
			);
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--paging.h-->
        <section>
            <hnew id="paging.h">paging.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#ifndef _PAGING_H</span>
<span style="font-style: italic">#define _PAGING_H</span>

<span style="font-style: italic">#include &quot;types.h&quot;</span>
<span style="font-style: italic">#include &quot;lib.h&quot;</span>
<span style="font-style: italic">#include &quot;system_calls.h&quot;</span>
<span style="font-style: italic">#include &quot;terminal.h&quot;</span>

<span style="font-style: italic">#define MAX_NUM_PROCESSES 8</span>
<span style="font-style: italic">#define FOUR_KB 4096</span>
<span style="font-style: italic">#define PAGE_DIR_SIZE			1024</span>
<span style="font-style: italic">#define PAGE_TABLE_SIZE			1024</span>
<span style="font-style: italic">#define PAGE_SIZE_32b			1024</span>
<span style="font-style: italic">#define PAGE_DIR_INIT_ENTRY		0x82 //Set 4 kb page size flag, R/W flag, but don&#39;t set present flag</span>
<span style="font-style: italic">#define SHIFT_i					12</span>
<span style="font-style: italic">#define MASK_HEX_TWO			0x2</span>
<span style="font-style: italic">#define MASK_HEX_THREE			0x3</span>
<span style="font-style: italic">#define IDX_VID_MEM_START		184</span>

<span style="font-style: italic">#define MASK_HEX_ZERO_THREE		0x03</span>
<span style="font-style: italic">#define RW_P_VALUE 				0x0083 // a better name for this would be S_R_FLAGS </span>
<span style="font-style: italic">#define S_R_FLAGS 				0x0043 // I created this to replace RW_P_FLAGS, which I thought was wrong</span>

<span style="font-style: italic">#define S_U_R_FLAGS 			0xC7 // a better name for this would be S_R_FLAGS </span>
<span style="font-style: italic">#define VIDMAP_PD_FLAGS			0x07</span>
<span style="font-style: italic">#define VIDMAP_PT_FLAGS			0x07</span>
<span style="font-style: italic">#define KERNEL_PAGE_ADDR 		0x400000</span>
<span style="font-style: italic">#define PROGRAM_ONE_PAGE 		0x800000</span>
<span style="font-style: italic">#define PROGRAM_TWO_PAGE 		0xC00000</span>
<span style="font-style: italic">#define VIDEO_MEMORY_START_ADDR 0x0000B8000</span>

<span style="font-style: italic">#define PROGRAM_4MB_PAGE_OFFSET (128 / 4)</span>
<span style="font-style: italic">#define USER_PDE_ENTRY_FLAGS 0x87 //is this discontinued? some of these flags may be just wrong and unused</span>
<span style="font-style: italic">#define MAX_NUM_TERMINALS 3</span>

<span style="font-style: italic">#define PHYS_ADDR_VIDEO_BACK_PAGES (20 * (4 * ONE_MEGABYTE))</span>
<span style="font-style: italic">#define ONE_MEGABYTE 0x100000</span>

<span style="font-style: italic">#define BACKPAGE_PG_ENTRY_IDX 20</span>

<span style="font-weight: bold">uint32_t</span> page_directory[PAGE_DIR_SIZE]  __attribute__((aligned(FOUR_KB))); <span style="font-style: italic">// align across 4 kb so that 12 LSB&#39;s of start are 0, so we can multiply indices to translate into addresses</span>
<span style="font-weight: bold">uint32_t</span> kernel_page[PAGE_TABLE_SIZE] __attribute__((aligned(FOUR_KB))); 
<span style="font-weight: bold">uint32_t</span> first_4_MB_page[PAGE_TABLE_SIZE] __attribute__((aligned(FOUR_KB)));

<span style="font-weight: bold">uint32_t</span> user_page_directories [MAX_NUM_PROCESSES * PAGE_DIR_SIZE] __attribute__((aligned(FOUR_KB)));
<span style="font-weight: bold">uint32_t</span> vid_map_page_tables [MAX_NUM_PROCESSES * PAGE_TABLE_SIZE] __attribute__((aligned(FOUR_KB)));
<span style="font-weight: bold">uint32_t</span> * terminal_video_back_pages;

<span style="font-weight: bold">void</span> init_paging ();

<span style="font-weight: bold">void</span> load_page_directory (<span style="font-weight: bold">uint32_t</span> page_directory_addr);

<span style="font-weight: bold">void</span> init_paging_user_program (<span style="font-weight: bold">uint32_t</span> physical_adress_program_big_page, <span style="font-weight: bold">uint32_t</span> child_pcb);

<span style="font-weight: bold">void</span> enable_paging ();


<span style="font-style: italic">#endif /* _PAGING_H */</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--scheduler.c-->
        <section>
            <hnew id="scheduler.c">scheduler.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#include &quot;scheduler.h&quot;</span>

<span style="font-style: italic">/*#define ESP 4</span>

<span style="font-style: italic">//note pcb_C should not be a pointer to an actual pcb, but a newly allocated pcb to </span>
<span style="font-style: italic">#define switch_process (pcb_A, pcb_B, pcb_C)                       \ //pcb_A - process to be switched out, pcb_B - process to switch to, pcb_C - last process to be executed (filled in by this macro)</span>
<span style="font-style: italic">do {                                    \</span>
<span style="font-style: italic">	asm volatile(&quot; movl pcb_A, %%eax; movl pcb_B, %%edx; pushfl; pushl %%ebp; \n &quot; //im not too sure about the pushfl and push ebp</span>
<span style="font-style: italic">		&quot;movl %%esp, ESP (%%eax);  \n&quot; //save the kernel stack pointer in the pcb field for esp0</span>
<span style="font-style: italic">		&quot;movl ESP (%%edx), %%esp; \n&quot; //set the kernel stack pointer of the new process</span>
<span style="font-style: italic">		&quot;leal resume, &lt;switching_out_pcb-&gt;tss-&gt;eip&gt;&quot; //force scheduler to pick up after the function call, so that the registers are popped and the system resumes executing the code at the code where this was pasted</span>
<span style="font-style: italic">		&quot;pushl &lt;switching_in_pcb-&gt;tss-&gt;eip&gt;&quot; //push new adress on kernel stack so that the next ret command jumps to the code of the new process</span>
<span style="font-style: italic">		&quot;movl &lt;switching_in_pcb-&gt;tss-&gt;cr3&gt;, %%cr3&quot; //note that here is where we must do everything that actual linux does in the switch_to actual function</span>
<span style="font-style: italic">		&quot;ret&quot;</span>
<span style="font-style: italic">		&quot;resume: popl saved registers here&quot; //really the registers that we have to save are all the ones that we touch in this macro. This isn&#39;t a c function, to the compiler, all registers should be unchanged thisthis is just a macro.</span>
<span style="font-style: italic">		:</span>
<span style="font-style: italic">		: &quot;g&quot; (pcb_A), &quot;g&quot; (pcb_B), &quot;g&quot; (pcb_C)</span>
<span style="font-style: italic">		: &quot;memory&quot;, &quot;edx&quot;, &quot;eax&quot;\</span>
<span style="font-style: italic">} while(0)</span>


<span style="font-style: italic">or we do this</span>


<span style="font-style: italic">movl %%esp, </span>


<span style="font-style: italic">To prepare for a process switch:</span>
<span style="font-style: italic">	we can always keep the tss eip on the top of the kernel stack for an inactive process</span>

<span style="font-style: italic">	pass in switching out, switiching in, and last executed pcbs</span>

<span style="font-style: italic">	kernel book says to save esi, edi, ebp in current (switching out) kernel stack</span>
<span style="font-style: italic">	movl %esp, switching_out_pcb-&gt;tss-&gt;esp</span>
<span style="font-style: italic">	movl switching_in_pcb-&gt;tss-&gt;esp, %esp</span>
<span style="font-style: italic">	movl </span>



<span style="font-style: italic">	stage the pcbs in registers. Parameters are passed into the switch_to function by registers because we use the kernel stack for other things like eip</span>
<span style="font-style: italic">	save registers that are modified but not understood to be clobbered by the compiler form the macro conventions</span>
<span style="font-style: italic">	swap out kernel stacks ( and thus processes)</span>
<span style="font-style: italic">	store the (adress after the function) into the old process&#39;s tss eip field, so that when the eip is restored in the next switch to call, it picks up where it left off</span>
<span style="font-style: italic">	throw the new process tss eip field onto the kernel stack...</span>
<span style="font-style: italic">	...and then jmp to the _switch_to function. (so that when it rets, it rets to the eip)</span>

<span style="font-style: italic">	another function will handle</span>

<span style="font-style: italic">	load cr3 with switching_to_pcb-&gt;tss-&gt;cr3</span>
<span style="font-style: italic">	fs and gs segment registers. Do we need these? What are these?</span>
<span style="font-style: italic">	pop all those registers saved</span>
<span style="font-style: italic">	ret so that you ret to that eip on the stack</span>

<span style="font-style: italic">	now when the scheduler picks the process again, it will pick up at that addr we saved in the tss eip</span>
<span style="font-style: italic">	that adress was purposefully the line of the macro after the function call</span>
<span style="font-style: italic">	So now we can...</span>
<span style="font-style: italic">	restore the registers</span>
<span style="font-style: italic">	remember that this is just a preprocessor macro, pasted in the middle of code. So the next line is to keep progressing through program</span>






<span style="font-style: italic">*/</span>

<span style="font-style: italic">#define ESP 4</span>

<span style="font-style: italic">/* discontinued function */</span>
<span style="font-weight: bold">int32_t</span> schedule ()
{
	<span style="font-weight: bold">return</span> 0;

}


<span style="font-style: italic">/*</span>
<span style="font-style: italic">check if cur_pcb-&gt;cr3 is set correctly</span>
<span style="font-style: italic">also next_pcb-&gt;cr3 must always be set corectly check that too</span>

<span style="font-style: italic">if init shell...</span>


<span style="font-style: italic">process 1</span>

<span style="font-style: italic">bunc hof stuff</span>
<span style="font-style: italic">process 2</span>

<span style="font-style: italic">offset_first_instruction</span>
<span style="font-style: italic">USER_CS</span>
<span style="font-style: italic">flags</span>
<span style="font-style: italic">USER_STACK_BASE_VM_LOC</span>
<span style="font-style: italic">USER_DS</span>

<span style="font-style: italic">*/</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--scheduler.h-->
        <section>
            <hnew id="scheduler.h">scheduler.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#ifndef _SCHEDULER_H</span>
<span style="font-style: italic">#define _SCHEDULER_H</span>

<span style="font-style: italic">#include &quot;file_system.h&quot;</span>
<span style="font-style: italic">#include &quot;paging.h&quot;</span>
<span style="font-style: italic">#include &quot;x86_desc.h&quot;</span>

<span style="font-weight: bold">int32_t</span> schedule ();

<span style="font-style: italic">#endif </span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--system_calls.c-->
        <section>
            <hnew id="system_calls.c">system_calls.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#include &quot;system_calls.h&quot;</span>
		 
<span style="font-style: italic">//process_struct_t* process_struct_stack_top = (process_struct_t*) 0x800000; //we maintain here a stack of process structs starting from the bottom of the kernel page. A stack was chosen here to better faciliate the dynamic loading and removal of programs.</span>
<span style="font-weight: bold">process_struct_t</span> * process_structs = (<span style="font-weight: bold">process_struct_t</span>*) (PROCESS_STACK_BASE - (PROCESS_STRUCT_SIZE * MAX_PROCESSES)); <span style="font-style: italic">//we maintain here a stack of process structs starting from the bottom of the kernel page. A stack was chosen here to better faciliate the dynamic loading and removal of programs.</span>
func type_0_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {(func)rtc_open, (func)rtc_read, (func)rtc_write, (func)rtc_close};
func type_1_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {(func)file_open, (func)dir_read, (func)file_write, (func)file_close};
func type_2_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {(func)file_open, (func)file_read, (func)file_read, (func)file_close};
<span style="font-weight: bold">int</span> num_active_processes = 0; 

<span style="font-weight: bold">void</span> jump_to_addr (<span style="font-weight: bold">uint32_t</span> addr);
 
  <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function:       execute_init_shell   </span>
<span style="font-style: italic">  * Description:    initializes the shell</span>
<span style="font-style: italic">  * Input:          name of program to be run</span>
<span style="font-style: italic">  * Side effects:   relinquishes control to user code and loads appropriate program image to memory</span>
<span style="font-style: italic">  * Output:         none</span>
<span style="font-style: italic">  * Return value:   0 on success, ERROR on failure</span>
<span style="font-style: italic">  */</span>



<span style="font-weight: bold">int</span> execute_init_shell (<span style="font-weight: bold">int</span> associated_terminal)
{

 	<span style="font-weight: bold">uint8_t</span> command [SHELL_WORD_SIZE] = {<span style="font-style: italic">&#39;s&#39;</span>, <span style="font-style: italic">&#39;h&#39;</span>, <span style="font-style: italic">&#39;e&#39;</span>, <span style="font-style: italic">&#39;l&#39;</span>, <span style="font-style: italic">&#39;l&#39;</span>, <span style="font-style: italic">&#39;\0&#39;</span> };
	cli();

	<span style="font-weight: bold">uint32_t</span> offset_first_instruction; <span style="font-style: italic">//offset of the first instruction in the executable</span>
	<span style="font-weight: bold">uint32_t</span> first_four_bytes;
	<span style="font-weight: bold">uint8_t</span> * program_executable_code = (<span style="font-weight: bold">uint8_t</span>*) USER_CODE_START;
	<span style="font-weight: bold">void</span>* stdin_file_operations_jump_table [STDIN_FILE_OP_JMP_TABLE_LENGTH] = {NULL, &amp;read_from_keyboard, NULL, NULL}; 	<span style="font-style: italic">// order: open, read, write, close</span>
	<span style="font-weight: bold">void</span>* stdout_file_operations_jump_table [STDOUT_FILE_OP_JMP_TABLE_LENGTH] = {NULL, NULL, &amp;write_to_terminal, NULL}; <span style="font-style: italic">//implement return 0 functions for rwocs that aren&#39;t used</span>
	<span style="font-weight: bold">int</span> src_fn_len; <span style="font-style: italic">//stores length of the program source file, for parsing</span>
	<span style="font-weight: bold">char</span> src_filename [F_NAME_SIZE]; <span style="font-style: italic">//stores the file name of the program source code</span>
	<span style="font-weight: bold">uint32_t</span> pid_of_new_child = ERROR_PID;
	<span style="font-weight: bold">dentry_t</span> program_dentry;
	<span style="font-weight: bold">int</span> i;

	src_fn_len = strlen ((<span style="font-weight: bold">char</span>*) command) + 1; <span style="font-style: italic">//. + 1 is critical because we need to copy the null character!!!!</span>
	<span style="font-style: italic">//strncpy (src_filename, (char*) command, src_fn_len); //store the pogram source code filename before paging is implemented. </span>
	<span style="font-weight: bold">for</span>(i = 0; i &lt; src_fn_len; i++) {
		<span style="font-weight: bold">if</span>(command[i] == <span style="font-style: italic">&#39; &#39;</span>) {
			src_filename[i] = <span style="font-style: italic">&#39;\0&#39;</span>; <span style="font-style: italic">// add null terminating charcter</span>
			i++;
			<span style="font-weight: bold">break</span>;
		}
		src_filename[i] = command[i]; <span style="font-style: italic">// store file name</span>
	}

	<span style="font-style: italic">// checks for valid file in file system img</span>
	<span style="font-weight: bold">if</span> (read_dentry_by_name ((<span style="font-weight: bold">uint8_t</span>*)src_filename, &amp;program_dentry)) {<span style="font-style: italic">// passing command for name will work because command begins with null terminated filename. VERIFY THAT it is actually null terminated, or will not work</span>
		<span style="font-weight: bold">return</span> ERROR;
	}

	<span style="font-style: italic">// checks if valid file is an executable</span>
	read_data (program_dentry.inode, 0, (<span style="font-weight: bold">uint8_t</span> *) &amp;first_four_bytes, ELF_FLAG_SIZE); <span style="font-style: italic">//check for the ELF flag</span>
	<span style="font-weight: bold">if</span> (first_four_bytes != ELF) { <span style="font-style: italic">//verify that the program file is an executable by checking for the elf flag</span>
		<span style="font-style: italic">//printf (&quot;Error in execute. Program NOT AN ELF. %x&quot;, first_four_bytes);</span>
		<span style="font-weight: bold">return</span> ERROR; <span style="font-style: italic">//elf flag was not present, file is not an executable, return error</span>
	}

	read_data (program_dentry.inode, FILE_SIZE_BYTE_INDICATOR_NO, (<span style="font-weight: bold">uint8_t</span> *) &amp;offset_first_instruction, FILE_SIZE_INDICATOR_NO_BYTES); <span style="font-style: italic">// get the offset of the first instruction to be executed, in bits 24 - 27 </span>

	<span style="font-style: italic">// gets new PID for process to be run</span>
	<span style="font-weight: bold">int</span> tmp_err = 0;
	pid_of_new_child = get_pid_for_new_process (&amp;tmp_err); <span style="font-style: italic">//assign a unique pid to process if available, else return error</span>
	<span style="font-weight: bold">if</span> (tmp_err == ERROR) <span style="font-weight: bold">return</span> ERROR; 
	terminals[associated_terminal].init_shell_pid = pid_of_new_child; <span style="font-style: italic">//each terminal has a starting shell, record the terminal&#39;s first shell</span>

	<span style="font-weight: bold">process_struct_t</span> *new_child_process_struct = &amp;process_structs[pid_of_new_child]; <span style="font-style: italic">// loads new process into process array</span>
	new_child_process_struct-&gt;pcb.pid = pid_of_new_child;

	terminal_pcb_stack [terminals[associated_terminal].terminal_idx] [terminal_pcb_stack_tops [terminals[associated_terminal].terminal_idx]++] = &amp;new_child_process_struct-&gt;pcb; <span style="font-style: italic">//pointer to the top of each stack</span>

	<span style="font-weight: bold">for</span> (i = FIRST_USER_PD_ENTRY_IDX - 1; i &lt; FIRST_USER_PD_ENTRY_IDX + MAX_NO_PROCESSES; i++) { <span style="font-style: italic">//loop through directory entries that can store programs</span>
		<span style="font-weight: bold">if</span> (page_directory[i] &amp; 0x001) <span style="font-style: italic">// check for presence of page</span>
			<span style="font-weight: bold">continue</span>; <span style="font-style: italic">//program is already loaded, check the next large page in PD</span>
		page_directory[i] &amp;= 0x001;
		init_paging_user_program (LARGE_PAGE_SIZE * i, (<span style="font-weight: bold">uint32_t</span>)&amp;(new_child_process_struct-&gt;pcb)); <span style="font-style: italic">// large page is not present, claim this page for the program</span>
		new_child_process_struct-&gt;pcb.starting_physical_addr_of_page = LARGE_PAGE_SIZE * i;
		new_child_process_struct-&gt;pcb.parent = NULL;
		<span style="font-weight: bold">break</span>;
	}
	<span style="font-weight: bold">if</span> (i == FIRST_USER_PD_ENTRY_IDX + MAX_NO_PROCESSES) <span style="font-style: italic">//no spaces found, loop executed to completion. </span>
			<span style="font-weight: bold">return</span> ERROR;

	read_data (program_dentry.inode, 0, program_executable_code, LARGE_PAGE_SIZE); <span style="font-style: italic">// read the entirity of the executable file until the end or until 4 mb page</span>

	<span style="font-style: italic">// assign file operation table for stdin</span>
	<span style="font-weight: bold">for</span> (i = 0; i &lt; STDIN_FILE_OP_JMP_TABLE_LENGTH; i++)
		new_child_process_struct-&gt;pcb.file_array[0].file_op_table[i] = stdin_file_operations_jump_table[i];

	new_child_process_struct-&gt;pcb.file_array[0].flags = FD_IN_USE_FLAG; <span style="font-style: italic">// open stdin</span>

	<span style="font-style: italic">// assign file operation table for stdout</span>
	<span style="font-weight: bold">for</span> (i = 0; i &lt; STDIN_FILE_OP_JMP_TABLE_LENGTH; i++)
		new_child_process_struct-&gt;pcb.file_array[1].file_op_table[i] = stdout_file_operations_jump_table[i];

	new_child_process_struct-&gt;pcb.file_array[1].flags = FD_IN_USE_FLAG; <span style="font-style: italic">// open stdout</span>

	<span style="font-style: italic">// mark rest of files as available</span>
	<span style="font-weight: bold">for</span>(i = FIRST_GENERAL_USE_FD; i &lt; ARRAY_SIZE; i++) <span style="font-style: italic">// set rest of File Descriptors to be free</span>
		new_child_process_struct-&gt;pcb.file_array[i].flags = FD_FREE_FLAG;


	new_child_process_struct-&gt;pcb.terminal_idx = associated_terminal;
	<span style="font-weight: bold">uint32_t</span> new_ebp_and_esp = (<span style="font-weight: bold">uint32_t</span>) (&amp;process_structs[new_child_process_struct-&gt;pcb.pid]) + PROCESS_STRUCT_SIZE - LONG_SIZE;

	tss.esp0 = new_ebp_and_esp - SIZEOF_FAKE_IRET_CONTEXT; <span style="font-style: italic">//(uint32_t)process_struct_stack_top + 1; // set new stack pointer to the bottom of the structure (begining of the stack). Needs verification.</span>
	tss.ss0 = KERNEL_DS;

  	new_child_process_struct-&gt;pcb.first_instruction_addr = offset_first_instruction; <span style="font-style: italic">// sets PCB value of entry offset</span>
	new_child_process_struct-&gt;pcb.vidmap_performed = 0; <span style="font-style: italic">//new process has not yet been vid mapped</span>

    new_child_process_struct-&gt;pcb.has_pit_context = 0;

	sti ();
	
	<span style="font-weight: bold">uint32_t</span> flags;
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot; pushfl; popl %%eax; movl %%eax, %0; &quot;</span>
					:<span style="font-style: italic">&quot;=r&quot;</span>(flags) : : <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>);

    asm <span style="font-weight: bold">volatile</span> ( 
    	<span style="font-style: italic">&quot;movl %5, %%ebx;&quot;</span> <span style="font-style: italic">//set up an iret context on the stack of the new shell so that it can be scheduled (since we are already starting it)</span>
    	<span style="font-style: italic">&quot;movl %0, %%edx; movl %%edx, (%%ebx);&quot;</span> 
    	<span style="font-style: italic">&quot;movl %1, %%edx; movl %%edx, -4(%%ebx); &quot;</span>
    	<span style="font-style: italic">&quot;movl %4, %%edx; movl %%edx, -8(%%ebx); &quot;</span>
    	<span style="font-style: italic">&quot;movl %2, %%edx; movl %%edx, -12(%%ebx); &quot;</span>
    	<span style="font-style: italic">&quot;movl %3, %%edx; movl %%edx, -16(%%ebx);&quot;</span>
      : <span style="font-style: italic">/* no outputs */</span>
      : <span style="font-style: italic">&quot;g&quot;</span>(USER_DS), <span style="font-style: italic">&quot;g&quot;</span>(USER_STACK_BASE_VM_LOC), <span style="font-style: italic">&quot;g&quot;</span>(USER_CS), <span style="font-style: italic">&quot;g&quot;</span> (offset_first_instruction), <span style="font-style: italic">&quot;g&quot;</span> (flags), <span style="font-style: italic">&quot;g&quot;</span>(new_ebp_and_esp) <span style="font-style: italic">//, &quot;g&quot; (0x0000200)</span>
      :  <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;ebx&quot;</span>, <span style="font-style: italic">&quot;esi&quot;</span>, <span style="font-style: italic">&quot;ecx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
    );

    <span style="font-weight: bold">uint32_t</span> cr3;
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot; movl %%cr3, %%ebx; movl %%ebx, %0;&quot;</span>
					:<span style="font-style: italic">&quot;=r&quot;</span>(cr3) : : <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;ebx&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>);
	new_child_process_struct-&gt;pcb.cr3 = cr3;

    new_child_process_struct-&gt;pcb.esp0 = (new_ebp_and_esp - SIZEOF_FAKE_IRET_CONTEXT); <span style="font-style: italic">//double check</span>
    new_child_process_struct-&gt;pcb.esp = (new_ebp_and_esp - SIZEOF_FAKE_IRET_CONTEXT); <span style="font-style: italic">//(new_ebp_and_esp - 20); //double check</span>
    new_child_process_struct-&gt;pcb.ebp = (new_ebp_and_esp); <span style="font-style: italic">//(new_ebp_and_esp - 20); //double check</span>

	<span style="font-weight: bold">return</span> 0;

 
   
}



 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		execute   </span>
<span style="font-style: italic">  * Description: 	system call that executes and runs a program</span>
<span style="font-style: italic">  * Input:			name of program to be run</span>
<span style="font-style: italic">  * Side effects:	relinquishes control to user code and loads appropriate program image to memory</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	0 on success, ERROR on failure</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> system_execute (<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* command)
{
	cli();

	<span style="font-weight: bold">uint32_t</span> offset_first_instruction; <span style="font-style: italic">//offset of the first instruction in the executable</span>
	<span style="font-weight: bold">uint32_t</span> first_four_bytes;
	<span style="font-weight: bold">uint8_t</span> * program_executable_code = (<span style="font-weight: bold">uint8_t</span>*) USER_CODE_START;
	<span style="font-weight: bold">void</span>* stdin_file_operations_jump_table [STDIN_FILE_OP_JMP_TABLE_LENGTH] = {NULL, &amp;read_from_keyboard, NULL, NULL}; 	<span style="font-style: italic">// order: open, read, write, close</span>
	<span style="font-weight: bold">void</span>* stdout_file_operations_jump_table [STDOUT_FILE_OP_JMP_TABLE_LENGTH] = {NULL, NULL, &amp;write_to_terminal, NULL}; <span style="font-style: italic">//implement return 0 functions for rwocs that aren&#39;t used</span>
	<span style="font-weight: bold">int</span> src_fn_len; <span style="font-style: italic">//stores length of the program source file, for parsing</span>
	<span style="font-weight: bold">char</span> src_filename [F_NAME_SIZE]; <span style="font-style: italic">//stores the file name of the program source code</span>
	<span style="font-weight: bold">uint8_t</span> arguments [ARGUMENTS_SIZE];
	<span style="font-weight: bold">uint32_t</span> pid_of_new_child = ERROR_PID;
	<span style="font-weight: bold">dentry_t</span> program_dentry;
	<span style="font-weight: bold">int</span> i, offset;

	src_fn_len = strlen ((<span style="font-weight: bold">char</span>*) command) + 1; <span style="font-style: italic">//. + 1 is critical because we need to copy the null character!!!!</span>
	<span style="font-style: italic">//strncpy (src_filename, (char*) command, src_fn_len); //store the pogram source code filename before paging is implemented. </span>
	<span style="font-weight: bold">for</span>(i = 0; i &lt; src_fn_len; i++) {
		<span style="font-weight: bold">if</span>(command[i] == <span style="font-style: italic">&#39; &#39;</span>) {
			src_filename[i] = <span style="font-style: italic">&#39;\0&#39;</span>; <span style="font-style: italic">// add null terminating charcter</span>
			i++;
			offset = i;
			<span style="font-weight: bold">for</span>(; i &lt; src_fn_len; i++) { <span style="font-style: italic">// copy arguments into buffer</span>
				arguments[i - offset] = command[i];
			}
			<span style="font-weight: bold">break</span>;
		}
		src_filename[i] = command[i]; <span style="font-style: italic">// store file name</span>
	}

	<span style="font-style: italic">// checks for valid file in file system img</span>
	<span style="font-weight: bold">if</span> (read_dentry_by_name ((<span style="font-weight: bold">uint8_t</span>*)src_filename, &amp;program_dentry)) {<span style="font-style: italic">// passing command for name will work because command begins with null terminated filename. VERIFY THAT it is actually null terminated, or will not work</span>
		<span style="font-weight: bold">return</span> ERROR;
	}

	<span style="font-style: italic">// checks if valid file is an executable</span>
	read_data (program_dentry.inode, 0, (<span style="font-weight: bold">uint8_t</span> *) &amp;first_four_bytes, ELF_FLAG_SIZE); <span style="font-style: italic">//check for the ELF flag</span>
	<span style="font-weight: bold">if</span> (first_four_bytes != ELF) { <span style="font-style: italic">//verify that the program file is an executable by checking for the elf flag</span>
		<span style="font-style: italic">//printf (&quot;Error in execute. Program NOT AN ELF. %x&quot;, first_four_bytes);</span>
		<span style="font-weight: bold">return</span> ERROR; <span style="font-style: italic">//elf flag was not present, file is not an executable, return error</span>
	}

	read_data (program_dentry.inode, FILE_SIZE_BYTE_INDICATOR_NO, (<span style="font-weight: bold">uint8_t</span> *) &amp;offset_first_instruction, FILE_SIZE_INDICATOR_NO_BYTES); <span style="font-style: italic">// get the offset of the first instruction to be executed, in bits 24 - 27 </span>

	<span style="font-style: italic">// gets new PID for process to be run</span>
	<span style="font-weight: bold">int</span> tmp_err = 0;
	pid_of_new_child = get_pid_for_new_process (&amp;tmp_err); <span style="font-style: italic">//assign a unique pid to process if available, else return error</span>
	<span style="font-weight: bold">if</span> (tmp_err == ERROR) <span style="font-weight: bold">return</span> ERROR; 

	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb;

	<span style="font-weight: bold">process_struct_t</span> *new_child_process_struct = &amp;process_structs[pid_of_new_child]; <span style="font-style: italic">// loads new process into process array</span>
	new_child_process_struct-&gt;pcb.pid = pid_of_new_child;

	<span style="font-weight: bold">if</span> (pid_of_new_child == 0) { <span style="font-style: italic">// checks if new process is initial shell of terminal 1, if so place process at SHELL_PHYS_MEM_START (8MB)</span>
		init_paging_user_program (SHELL_PHYS_MEM_START, (<span style="font-weight: bold">uint32_t</span>)&amp;(new_child_process_struct-&gt;pcb));
		new_child_process_struct-&gt;pcb.starting_physical_addr_of_page = NO_RESERVED_SYS_BIG_PAGES * LARGE_PAGE_SIZE;
		new_child_process_struct-&gt;pcb.parent = NULL;
	}
	<span style="font-weight: bold">else</span> { <span style="font-style: italic">// checks if not inital shell, if so place next process starting at 12MB</span>
		<span style="font-weight: bold">for</span> (i = FIRST_USER_PD_ENTRY_IDX; i &lt; FIRST_USER_PD_ENTRY_IDX + MAX_NO_PROCESSES; i++) { <span style="font-style: italic">//loop through directory entries that can store programs</span>
				<span style="font-weight: bold">if</span> (page_directory[i] &amp; 0x001) <span style="font-style: italic">// check for presence of page</span>
					<span style="font-weight: bold">continue</span>; <span style="font-style: italic">//program is already loaded, check the next large page in PD</span>
			page_directory[i] &amp;= 0x001;
			init_paging_user_program (LARGE_PAGE_SIZE * i, (<span style="font-weight: bold">uint32_t</span>)&amp;(new_child_process_struct-&gt;pcb)); <span style="font-style: italic">// large page is not present, claim this page for the program</span>
			new_child_process_struct-&gt;pcb.starting_physical_addr_of_page = LARGE_PAGE_SIZE * i;
			cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
			new_child_process_struct-&gt;pcb.parent = cur_pcb;
			<span style="font-weight: bold">for</span>(i = 0; i &lt; ARGUMENTS_SIZE; i++) <span style="font-style: italic">// copt argument data</span>
				new_child_process_struct-&gt;pcb.arguments[i] = arguments[i]; <span style="font-style: italic">// load argument data</span>
			<span style="font-weight: bold">break</span>;
		}
		<span style="font-weight: bold">if</span> (i == FIRST_USER_PD_ENTRY_IDX + MAX_NO_PROCESSES) { <span style="font-style: italic">//no spaces found, loop executed to completion. </span>
			<span style="font-weight: bold">return</span> ERROR;
		}
	}

	read_data (program_dentry.inode, 0, program_executable_code, LARGE_PAGE_SIZE); <span style="font-style: italic">// read the entirity of the executable file until the end or until 4 mb page</span>

	<span style="font-style: italic">// assign file operation table for stdin</span>
	<span style="font-weight: bold">for</span> (i = 0; i &lt; STDIN_FILE_OP_JMP_TABLE_LENGTH; i++)
		new_child_process_struct-&gt;pcb.file_array[0].file_op_table[i] = stdin_file_operations_jump_table[i];

	new_child_process_struct-&gt;pcb.file_array[0].flags = FD_IN_USE_FLAG; <span style="font-style: italic">// open stdin</span>

	<span style="font-style: italic">// assign file operation table for stdout</span>
	<span style="font-weight: bold">for</span> (i = 0; i &lt; STDIN_FILE_OP_JMP_TABLE_LENGTH; i++)
		new_child_process_struct-&gt;pcb.file_array[1].file_op_table[i] = stdout_file_operations_jump_table[i];

	new_child_process_struct-&gt;pcb.file_array[1].flags = FD_IN_USE_FLAG; <span style="font-style: italic">// open stdout</span>

	<span style="font-style: italic">// mark rest of files as available</span>
	<span style="font-weight: bold">for</span>(i = FIRST_GENERAL_USE_FD; i &lt; ARRAY_SIZE; i++) <span style="font-style: italic">// set rest of File Descriptors to be free</span>
		new_child_process_struct-&gt;pcb.file_array[i].flags = FD_FREE_FLAG;

	<span style="font-weight: bold">if</span> (new_child_process_struct-&gt;pcb.pid != 0) <span style="font-style: italic">//tempoary hack, remove when the time is right</span>
		new_child_process_struct-&gt;pcb.terminal_idx = new_child_process_struct-&gt;pcb.parent-&gt;terminal_idx; <span style="font-style: italic">//assume this function will never be called to execute the initial shell anymore. because it will crash now</span>
	
	terminal_pcb_stack [active_terminal-&gt;terminal_idx] [terminal_pcb_stack_tops [active_terminal-&gt;terminal_idx]++] = &amp;new_child_process_struct-&gt;pcb; <span style="font-style: italic">//pointer to the top of each stack</span>

	<span style="font-style: italic">// gets current esp value</span>
	<span style="font-weight: bold">uint32_t</span> esp;
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot; movl %%esp, %0 ;&quot;</span>
					: <span style="font-style: italic">&quot;=r&quot;</span>(esp) : : <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>);

	<span style="font-style: italic">// gets current ebp value</span>
	<span style="font-weight: bold">uint32_t</span> ebp;
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot; movl %%ebp, %0 ;&quot;</span>
					: <span style="font-style: italic">&quot;=r&quot;</span>(ebp) : : <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>);
    <span style="font-weight: bold">uint32_t</span> cr3;
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot; movl %%cr3, %%ebx; movl %%ebx, %0;&quot;</span>
					:<span style="font-style: italic">&quot;=r&quot;</span>(cr3) : : <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;ebx&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>);
	new_child_process_struct-&gt;pcb.cr3 = cr3;

	<span style="font-style: italic">// save esp/ebp values</span>
	<span style="font-weight: bold">if</span> (new_child_process_struct-&gt;pcb.pid != 0) {<span style="font-style: italic">//no need to do this for the first call to execute shell, the esp is irrelevant</span>
			cur_pcb-&gt;esp0 = esp; <span style="font-style: italic">//(uint32_t) cur_pcb + PROCESS_STRUCT_SIZE - 1;//esp;</span>
			cur_pcb-&gt;ebp = ebp;
	}

	tss.esp0 = (<span style="font-weight: bold">uint32_t</span>) (&amp;process_structs[new_child_process_struct-&gt;pcb.pid]) + PROCESS_STRUCT_SIZE - LONG_SIZE; <span style="font-style: italic">//(uint32_t)process_struct_stack_top + 1; // set new stack pointer to the bottom of the structure (begining of the stack). Needs verification.</span>
	tss.ss0 = KERNEL_DS;
 
 	new_child_process_struct-&gt;pcb.first_instruction_addr = offset_first_instruction; <span style="font-style: italic">// sets PCB value of entry offset</span>

	sti ();

	new_child_process_struct-&gt;pcb.esp0 = (tss.esp0 - SIZEOF_FAKE_IRET_CONTEXT); <span style="font-style: italic">//double check</span>
    new_child_process_struct-&gt;pcb.esp = (tss.esp0 - SIZEOF_FAKE_IRET_CONTEXT); <span style="font-style: italic">//(new_ebp_and_esp - 20); //double check</span>
    new_child_process_struct-&gt;pcb.ebp = (tss.esp0); <span style="font-style: italic">//(new_ebp_and_esp - 20); //double check</span>

    new_child_process_struct-&gt;pcb.has_pit_context = 0;

	<span style="font-style: italic">// executes user program code</span>
    asm <span style="font-weight: bold">volatile</span> (
    	<span style="font-style: italic">&quot;pushl %0; pushl %1; pushfl ; pushl %2; pushl %3 </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">    	 movl $0xFFFFE000, %%edx </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">		 andl %%esp, %%edx </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">		 leal execute_post_program_launch, %%ebx </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">		 movl %%ebx, (%%edx) </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">    	 iret </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">    	 execute_post_program_launch: &quot;</span> <span style="font-style: italic">// push interrupt context onto the stack. TODO: figure out eflags</span>
      : <span style="font-style: italic">/* no outputs */</span>
      : <span style="font-style: italic">&quot;g&quot;</span>(USER_DS), <span style="font-style: italic">&quot;g&quot;</span>(USER_STACK_BASE_VM_LOC), <span style="font-style: italic">&quot;g&quot;</span>(USER_CS), <span style="font-style: italic">&quot;g&quot;</span> (offset_first_instruction) <span style="font-style: italic">//, &quot;g&quot; (0x0000200)</span>
      :  <span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;ebx&quot;</span>, <span style="font-style: italic">&quot;esi&quot;</span>, <span style="font-style: italic">&quot;ecx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>
    );



    <span style="font-style: italic">// frees PID now that user program is finished</span>
	available_pids[new_child_process_struct-&gt;pcb.pid] = 0;

	<span style="font-style: italic">// checks if program halted by exception</span>
	<span style="font-weight: bold">if</span>(new_child_process_struct-&gt;pcb.halt_status == EXCEPTION_OCCURED)
		<span style="font-weight: bold">return</span> (EXCEPTION_OCCURED + 1); <span style="font-style: italic">// since it&#39;s only 8bits, max value is 255 and exceptions return 256</span>
	<span style="font-weight: bold">else</span>
    	<span style="font-weight: bold">return</span> new_child_process_struct-&gt;pcb.halt_status;
   <span style="font-style: italic">// asm volatile (&quot; movl %0, %%eax; movl %1, %%esp ret;&quot; : : &quot;g&quot; (return_value), &quot;g&quot; (tss.esp0): &quot;memory&quot;)</span>
}

 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		system_halt   </span>
<span style="font-style: italic">  * Description: 	halts the current program being run and restores control to parent process unless it&#39;s the initial shell</span>
<span style="font-style: italic">  * Input:			status of program halt, 0 for normal halt, 255 for halt by exception, other for abnormal halting</span>
<span style="font-style: italic">  * Side effects:	returns to parent process unless it&#39;s the inital shell</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	0</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> system_halt (<span style="font-weight: bold">uint8_t</span> status)
{
	cli();

	<span style="font-weight: bold">int</span> fd;
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();

    <span style="font-weight: bold">terminal_t</span> * current_terminal = &amp;terminals[cur_pcb-&gt;terminal_idx];

	<span style="font-weight: bold">if</span> (cur_pcb-&gt;pid == current_terminal-&gt;init_shell_pid) { <span style="font-style: italic">// if trying to halt initial shell of a terminal, jump to first execution of user code for shell</span>
		sti();
		jump_to_addr (cur_pcb-&gt;first_instruction_addr);
	}

	<span style="font-style: italic">// reset esp/ss to parent process/kernal priv</span>
	<span style="font-style: italic">//tss.esp0 = cur_pcb-&gt;parent-&gt;esp0;</span>
	tss.esp0 = cur_pcb-&gt;parent-&gt;ebp;
	tss.ss0 = KERNEL_DS;


	load_page_directory((<span style="font-weight: bold">uint32_t</span>)cur_pcb-&gt;parent-&gt;pg_dir_table); <span style="font-style: italic">// switch pages to parent</span>

	<span style="font-style: italic">// close all associated files, is this the correct way though?</span>
	<span style="font-weight: bold">for</span> (fd = 0; fd &lt; MAX_PROCESSES; fd++)
		file_close(fd);

	<span style="font-style: italic">// if(status == EXCEPTION_OCCURED)</span>
	<span style="font-style: italic">// 	cur_pcb-&gt;halt_status = 1;</span>
	cur_pcb-&gt;halt_status = status;

	page_directory[cur_pcb-&gt;starting_physical_addr_of_page / LARGE_PAGE_SIZE] ^= 0x01; <span style="font-style: italic">//toggle present </span>

	terminal_pcb_stack [current_terminal-&gt;terminal_idx] [terminal_pcb_stack_tops [current_terminal-&gt;terminal_idx]--] = NULL; <span style="font-style: italic">//pointer to the top of each stack</span>

	<span style="font-style: italic">// jump back to end of execute of current program</span>
	sti();
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot; movl %0, %%ebx; movl %1, %%esp; movl %2, %%ebp; jmp *%%ebx ;&quot;</span> 
	:
	: <span style="font-style: italic">&quot;g&quot;</span> (cur_pcb-&gt;parent-&gt;return_to_exec_addr),  <span style="font-style: italic">&quot;g&quot;</span> (cur_pcb-&gt;parent-&gt;esp0), <span style="font-style: italic">&quot;g&quot;</span> (cur_pcb-&gt;parent-&gt;ebp)
	: <span style="font-style: italic">&quot;memory&quot;</span>
	);

	<span style="font-weight: bold">return</span> 0;
}


 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		system_read</span>
<span style="font-style: italic">  * Description: 	performs read system call depending on file operations table</span>
<span style="font-style: italic">  * Input:			file descriptor, buffer to read from, number of bytes to be read</span>
<span style="font-style: italic">  * Side effects:	jumps to associated read system call</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	number of bytes read</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> system_read(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes) {
	<span style="font-weight: bold">if</span>(fd &lt; 0 || fd &gt;= MAX_FD || fd == 1 || buf == <span style="font-style: italic">&#39;\0&#39;</span>) { <span style="font-style: italic">// fd cannot be less than 0 or greater than 7, cannot write to stdout</span>
		<span style="font-weight: bold">return</span> ERROR;
	}
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();

	<span style="font-weight: bold">if</span>(cur_pcb-&gt;file_array[fd].flags != 1) <span style="font-style: italic">// checks if file is open</span>
		<span style="font-weight: bold">return</span> ERROR;

	<span style="font-style: italic">// void* (*func)(uint32_t, const void*, uint32_t) = cur_pcb-&gt;file_array[fd].file_op_table[1]; // makes function pointer based on file operations jump table</span>
	<span style="font-style: italic">// return (int)(*func)(fd, buf, nbytes);</span>

	<span style="font-weight: bold">return</span> ((read)cur_pcb-&gt;file_array[fd].file_op_table[FILE_OP_TABLE_IDX_READ])(fd, buf, nbytes);
}

 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		system_write</span>
<span style="font-style: italic">  * Description: 	performs write system call depending on file operations table</span>
<span style="font-style: italic">  * Input:			file descriptor, buffer to write from, number of bytes to be written</span>
<span style="font-style: italic">  * Side effects:	jumps to associated write system call</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	number of bytes written</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> system_write(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes) {
	<span style="font-weight: bold">if</span>(fd &lt; 0 || fd &gt;= MAX_FD || fd == 0 || buf == <span style="font-style: italic">&#39;\0&#39;</span>) { <span style="font-style: italic">// fd cannot be less than 0 or greater than 7, cannot write to stdin</span>
		<span style="font-weight: bold">return</span> ERROR;
	}
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();

	<span style="font-weight: bold">if</span>(cur_pcb-&gt;file_array[fd].flags != 1) <span style="font-style: italic">// checks if file is open</span>
		<span style="font-weight: bold">return</span> ERROR;

	<span style="font-style: italic">// void* (*func)(uint32_t, const void*, uint32_t) = cur_pcb-&gt;file_array[fd].file_op_table[FILE_OP_TABLE_IDX_WRITE]; // makes function pointer based on file operations jump table</span>
	<span style="font-style: italic">// return (int)(*func)(fd, (void *) buf, nbytes);</span>

	<span style="font-weight: bold">return</span> ((write)cur_pcb-&gt;file_array[fd].file_op_table[FILE_OP_TABLE_IDX_WRITE])(fd, buf, nbytes);
}


 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		system_open</span>
<span style="font-style: italic">  * Description: 	opens the file if present in file system image</span>
<span style="font-style: italic">  * Input:			file name</span>
<span style="font-style: italic">  * Side effects:	opens file and sets file descriptor</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	fd of file opened, -1 on failure</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> system_open(<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* filename) {
	<span style="font-style: italic">//return file_open(filename);</span>
	<span style="font-weight: bold">int</span> fd = MIN_FD;
	<span style="font-weight: bold">int</span> i;
	<span style="font-weight: bold">dentry_t</span> dentry;
	<span style="font-style: italic">// func type_0_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {(func)rtc_open, (func)rtc_read, (func)rtc_write, (func)rtc_close};</span>
	<span style="font-style: italic">// func type_1_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {(func)file_open, (func)dir_read, (func)file_write, (func)file_close};</span>
	<span style="font-style: italic">// func type_2_file_operations_jump_table [FILE_OP_TABLE_SIZE] = {(func)file_open, (func)file_read, (func)file_read, (func)file_close};</span>


	<span style="font-weight: bold">if</span>(filename[0] == <span style="font-style: italic">&#39;\0&#39;</span>)
		<span style="font-weight: bold">return</span> ERROR;

	<span style="font-weight: bold">if</span>(read_dentry_by_name(filename, &amp;dentry) != 0) { <span style="font-style: italic">// check for valid file</span>
		<span style="font-weight: bold">return</span> ERROR;
	}

	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *)get_pcb_of_cur_process ();


	<span style="font-weight: bold">while</span>(cur_pcb-&gt;file_array[fd].flags != 0) { <span style="font-style: italic">// check for unused file desciptors</span>
		<span style="font-weight: bold">if</span>(fd == ARRAY_SIZE) {
			<span style="font-weight: bold">return</span> ERROR; <span style="font-style: italic">// if no unused file descriptors return -1</span>
		}
		fd++;
	}

	cur_pcb-&gt;file_array[fd].flags = 1;
	cur_pcb-&gt;file_array[fd].inode = dentry.inode;
	cur_pcb-&gt;file_array[fd].file_pos = 0;

	<span style="font-weight: bold">switch</span>(dentry.file_type) {
		<span style="font-weight: bold">case</span> 0: <span style="font-style: italic">// RTC</span>
			<span style="font-weight: bold">for</span>(i = 0; i &lt; FILE_OP_TABLE_SIZE; i++) {
				cur_pcb-&gt;file_array[fd].file_op_table[i] = type_0_file_operations_jump_table[i];
			}
			<span style="font-style: italic">//rtc_open();</span>
			<span style="font-weight: bold">break</span>;
		<span style="font-weight: bold">case</span> 1: <span style="font-style: italic">// directory</span>
			<span style="font-weight: bold">for</span>(i = 0; i &lt; FILE_OP_TABLE_SIZE; i++) {
				cur_pcb-&gt;file_array[fd].file_op_table[i] = type_1_file_operations_jump_table[i];
			}
			<span style="font-weight: bold">break</span>;
		default: <span style="font-style: italic">// regular file</span>
			<span style="font-weight: bold">for</span>(i = 0; i &lt; FILE_OP_TABLE_SIZE; i++) {
				cur_pcb-&gt;file_array[fd].file_op_table[i] = type_2_file_operations_jump_table[i];
			}
			<span style="font-weight: bold">break</span>;
	}

	<span style="font-weight: bold">if</span>(((open)cur_pcb-&gt;file_array[fd].file_op_table[0])(filename) != 0)
		<span style="font-weight: bold">return</span> ERROR;

	<span style="font-weight: bold">return</span> fd;
}

 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		system_close</span>
<span style="font-style: italic">  * Description: 	closes the file and marks it&#39;s file descriptor as unused</span>
<span style="font-style: italic">  * Input:			file descriptor index</span>
<span style="font-style: italic">  * Side effects:	jumps to assocaited system close call</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	0 on success, -1 on failure</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> system_close(<span style="font-weight: bold">int32_t</span> fd) {
	<span style="font-weight: bold">if</span>(fd &lt; MIN_FD || fd &gt;= MAX_FD) { <span style="font-style: italic">// cannot close default descriptors or invalid descriptors</span>
		<span style="font-weight: bold">return</span> ERROR;
	}
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process(); <span style="font-style: italic">// makes function pointer based on file operations jump table</span>

	<span style="font-weight: bold">if</span>(cur_pcb-&gt;file_array[fd].flags != 1) <span style="font-style: italic">// checks if file is open</span>
		<span style="font-weight: bold">return</span> ERROR;

	<span style="font-style: italic">// void* (*func)(uint32_t) = cur_pcb-&gt;file_array[fd].file_op_table[FILE_OP_TABLE_IDX];</span>
	<span style="font-style: italic">// return (int)(*func)(fd);</span>
	<span style="font-weight: bold">return</span> ((close)cur_pcb-&gt;file_array[fd].file_op_table[FILE_OP_TABLE_IDX])(fd);
}



 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		system_getargs</span>
<span style="font-style: italic">  * Description: 	reads current command line arguments into a user-level buffer</span>
<span style="font-style: italic">  * Input:			pointer to a buffer, number of bytes to be read</span>
<span style="font-style: italic">  * Side effects:	populates a user level buffer with the command line arguments</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	0 on success, -1 if there is no null terminating character or if argument is too large for user level buffer</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> system_getargs(<span style="font-weight: bold">uint8_t</span>* buf, <span style="font-weight: bold">int</span> nbytes) {
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	<span style="font-weight: bold">int</span> i;
	<span style="font-weight: bold">int</span> null_flag = 0;
	<span style="font-weight: bold">for</span>(i = 0; i &lt; nbytes; i++) { <span style="font-style: italic">// transfer contents of arguments buffer to user space</span>
		buf[i] = cur_pcb-&gt;arguments[i];
		<span style="font-weight: bold">if</span>(buf[i] == <span style="font-style: italic">&#39;\0&#39;</span>)
			null_flag = 1;
	}
	<span style="font-weight: bold">if</span>(null_flag) <span style="font-style: italic">// checks that a null terminating flag is present</span>
		<span style="font-weight: bold">return</span> 0;
	<span style="font-weight: bold">else</span> 
		<span style="font-weight: bold">return</span> ERROR;
}

 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		get_pcb_of_cur_process</span>
<span style="font-style: italic">  * Description: 	gets the base address of the current process&#39;s program control block</span>
<span style="font-style: italic">  * Input:			none</span>
<span style="font-style: italic">  * Side effects:	none</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	address of a program control block</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">uint32_t</span> get_pcb_of_cur_process ()
{
	<span style="font-weight: bold">uint32_t</span> pcb;
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot; movl $0xFFFFE000, %%edx; </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">					andl %%esp, %%edx; </span><span style="font-weight: bold; font-style: italic">\n</span><span style="font-style: italic">\</span>
<span style="font-style: italic">					movl %%edx, %0;&quot;</span>
					: <span style="font-style: italic">&quot;=r&quot;</span>(pcb) : :<span style="font-style: italic">&quot;edx&quot;</span>, <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;cc&quot;</span>); <span style="font-style: italic">/* get the pcb of the current process*/</span>
	<span style="font-weight: bold">return</span> pcb;
}


 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		jump_to_addr</span>
<span style="font-style: italic">  * Description: 	forces a jump to a specific address</span>
<span style="font-style: italic">  * Input:			address to be jumped to</span>
<span style="font-style: italic">  * Side effects:	forces the system to execute a jump</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	none</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">void</span> jump_to_addr (<span style="font-weight: bold">uint32_t</span> addr) 
{
	asm <span style="font-weight: bold">volatile</span> (<span style="font-style: italic">&quot;movl %0, %%ebx; jmp *%%ebx ;&quot;</span> : : <span style="font-style: italic">&quot;g&quot;</span> (addr) : <span style="font-style: italic">&quot;memory&quot;</span>, <span style="font-style: italic">&quot;ebx&quot;</span>);
}


 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		get_pid_for_new_process</span>
<span style="font-style: italic">  * Description: 	searches the array of PIDs for an available index, sets an error if none are free</span>
<span style="font-style: italic">  * Input:			pointer to the error check variable</span>
<span style="font-style: italic">  * Side effects:	set the error check variable if no PIDs are available</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value: 	PID index</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int</span> get_pid_for_new_process (<span style="font-weight: bold">int</span>* err)
{
	<span style="font-weight: bold">uint32_t</span> pid;

	<span style="font-weight: bold">for</span> (pid = 0; pid &lt; MAX_PROCESSES; pid++) {
		<span style="font-weight: bold">if</span> (available_pids[pid] == 0)
			<span style="font-weight: bold">break</span>;
	}
	<span style="font-weight: bold">if</span> (pid == MAX_PROCESSES)
			*err = ERROR;

	available_pids[pid] = 1;
	<span style="font-weight: bold">return</span> pid;
}

 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		vidmap</span>
<span style="font-style: italic">  * Description: 	Maps video memory to predefined location in user space, modifies </span>
<span style="font-style: italic">  * Input:			double pointer to the memory location of where to store the pointer to the virtual adress of the video memory mapping</span>
<span style="font-style: italic">  * Side effects:	sets up page entries at 132 MB for 4 kb virtual page mapping to video memory</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value:   -1 on ERROR, 0 on success</span>
<span style="font-style: italic">  */</span>

<span style="font-weight: bold">int32_t</span> vidmap (<span style="font-weight: bold">uint8_t</span>** screen_start)
{
	<span style="font-weight: bold">uint32_t</span> vidmap_virtual_mapping = USER_PROGRAM_VM_LOC + MEGABYTES_PER_PROGRAM_REGION * ONE_MEGABYTE;

	<span style="font-weight: bold">if</span> (((<span style="font-weight: bold">uint32_t</span>) screen_start &lt; USER_PROGRAM_VM_LOC) || ((<span style="font-weight: bold">uint32_t</span>) screen_start &gt;= (USER_PROGRAM_VM_LOC + MEGABYTES_PER_PROGRAM_REGION * ONE_MEGABYTE)))
		<span style="font-weight: bold">return</span> -1;
	<span style="font-weight: bold">int</span> <span style="font-weight: bold">idx_vidmap_pg_t</span> = (((<span style="font-weight: bold">uint32_t</span>) vidmap_virtual_mapping) &amp; PAGE_TABLE_MASK) &gt;&gt; PAGE_TABLE_SHIFT;
	<span style="font-weight: bold">int</span> <span style="font-weight: bold">idx_vidmap_pd_t</span> = (((<span style="font-weight: bold">uint32_t</span>) vidmap_virtual_mapping) &amp; PAGE_DIRECTORY_MASK) &gt;&gt; PAGE_DIRECTORY_SHIFT;
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();
	cur_pcb-&gt;pg_dir_table[<span style="font-weight: bold">idx_vidmap_pd_t</span>] = ((<span style="font-weight: bold">uint32_t</span>) (&amp;vid_map_page_tables [cur_pcb-&gt;pid * PAGE_TABLE_SIZE])) | VIDMAP_PD_FLAGS;
	<span style="font-weight: bold">uint32_t</span> * the_page_table = &amp;vid_map_page_tables [cur_pcb-&gt;pid * PAGE_TABLE_SIZE];
	the_page_table [<span style="font-weight: bold">idx_vidmap_pg_t</span>] = VIDEO_MEM_START_ADDR | VIDMAP_PT_FLAGS;
	*screen_start = (<span style="font-weight: bold">uint8_t</span>*)vidmap_virtual_mapping;

	cur_pcb-&gt;vidmap_performed = 1;
	<span style="font-weight: bold">return</span> 0; <span style="font-style: italic">//(int32_t) screen_start; //no idea why we would return this...its probably wrong.</span>
}

<span style="font-weight: bold">int32_t</span> vidremap (<span style="font-weight: bold">program_control_block_t</span> * cur_pcb, <span style="font-weight: bold">uint32_t</span> remaped_here)
{
	<span style="font-weight: bold">uint32_t</span> vidmap_virtual_mapping = USER_PROGRAM_VM_LOC + MEGABYTES_PER_PROGRAM_REGION * ONE_MEGABYTE;

	<span style="font-weight: bold">int</span> <span style="font-weight: bold">idx_vidmap_pg_t</span> = (((<span style="font-weight: bold">uint32_t</span>) vidmap_virtual_mapping) &amp; PAGE_TABLE_MASK) &gt;&gt; PAGE_TABLE_SHIFT;
	<span style="font-weight: bold">int</span> <span style="font-weight: bold">idx_vidmap_pd_t</span> = (((<span style="font-weight: bold">uint32_t</span>) vidmap_virtual_mapping) &amp; PAGE_DIRECTORY_MASK) &gt;&gt; PAGE_DIRECTORY_SHIFT;
	cur_pcb-&gt;pg_dir_table[<span style="font-weight: bold">idx_vidmap_pd_t</span>] = ((<span style="font-weight: bold">uint32_t</span>) (&amp;vid_map_page_tables [cur_pcb-&gt;pid * PAGE_TABLE_SIZE])) | VIDMAP_PD_FLAGS;
	<span style="font-weight: bold">uint32_t</span> * the_page_table = &amp;vid_map_page_tables [cur_pcb-&gt;pid * PAGE_TABLE_SIZE];
	the_page_table [<span style="font-weight: bold">idx_vidmap_pg_t</span>] = remaped_here | VIDMAP_PT_FLAGS;

	<span style="font-weight: bold">return</span> 0; <span style="font-style: italic">//(int32_t) screen_start; //no idea why we would return this...its probably wrong.</span>
}

 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		set_handler</span>
<span style="font-style: italic">  * Description: 	signaling in progress</span>
<span style="font-style: italic">  * Input:			signal number, address of signal handler</span>
<span style="font-style: italic">  * Side effects:	none</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value:   -1 on ERROR</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int32_t</span> set_handler (<span style="font-weight: bold">int32_t</span> signum, <span style="font-weight: bold">void</span> * handler_address)
{
	<span style="font-weight: bold">return</span> ERROR;
}


 <span style="font-style: italic">/*</span>
<span style="font-style: italic">  * Function: 		sigreturn</span>
<span style="font-style: italic">  * Description: 	signaling in progress</span>
<span style="font-style: italic">  * Input:			none</span>
<span style="font-style: italic">  * Side effects:	none</span>
<span style="font-style: italic">  * Output:       	none</span>
<span style="font-style: italic">  * Return value:   -1 on ERROR</span>
<span style="font-style: italic">  */</span>
<span style="font-weight: bold">int32_t</span> sigreturn (<span style="font-weight: bold">void</span>)
{
	<span style="font-weight: bold">return</span> ERROR;
}
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--system_calls.h-->
        <section>
            <hnew id="system_calls.h">system_calls.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#ifndef _SYSTEM_CALLS_H</span>
<span style="font-style: italic">#define _SYSTEM_CALLS_H</span>

<span style="font-style: italic">#include &quot;file_system.h&quot;</span>
<span style="font-style: italic">#include &quot;paging.h&quot;</span>
<span style="font-style: italic">#include &quot;x86_desc.h&quot;</span>

<span style="font-style: italic">#define TBD (-1) //anything set to here is tbd and obviously will be changed later</span>
<span style="font-style: italic">#define ERROR (-1) // to be set later</span>
<span style="font-style: italic">#define ELF_FLAG_SIZE 4</span>
<span style="font-style: italic">#define LARGE_PAGE_SIZE (4 * 1024 * 1024)</span>
<span style="font-style: italic">#define ELF  0x464C457F //verified, kindof</span>
<span style="font-style: italic">#define USER_PROGRAM_VM_LOC (128 * ONE_MEGABYTE) //0x08000000 // 128 MB</span>
<span style="font-style: italic">#define FOUR_KB 4096</span>
<span style="font-style: italic">#define USER_STACK_BASE_VM_LOC (USER_PROGRAM_VM_LOC + LARGE_PAGE_SIZE - 4)</span>
<span style="font-style: italic">#define USER_CODE_START 0x08048000</span>
<span style="font-style: italic">#define SHELL_PHYS_MEM_START 0x800000</span>
<span style="font-style: italic">#define PROGRAM_PAGES_END (FIRST_PROGRAM_START + LARGE_PAGE_SIZE * 8)</span>
<span style="font-style: italic">#define PROCESS_STACK_BASE 0x800000 //redundant</span>
<span style="font-style: italic">#define PROCESS_STRUCT_SIZE 0x2000</span>
<span style="font-style: italic">#define PCB_SIZE 405 //404 // ALWAYS NEED TO UPDATE THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span>
<span style="font-style: italic">#define KERNEL_STACK_LENGTH ((PROCESS_STRUCT_SIZE - PCB_SIZE) / 4)  //remember length is in words</span>
<span style="font-style: italic">#define STDIN_FILE_OP_JMP_TABLE_LENGTH 4 </span>
<span style="font-style: italic">#define STDOUT_FILE_OP_JMP_TABLE_LENGTH 4</span>
<span style="font-style: italic">#define FD_IN_USE_FLAG 1 </span>
<span style="font-style: italic">#define FD_FREE_FLAG 0</span>
<span style="font-style: italic">#define MAX_PROCESSES 8</span>
<span style="font-style: italic">#define ONE_MEGABYTE 0x100000</span>
<span style="font-style: italic">#define KERNEL_PAGE_START (4 * ONE_MEGABYTE)</span>
<span style="font-style: italic">#define KERNEL_PAGE_END (8 * ONE_MEGABYTE)</span>
<span style="font-style: italic">#define EXCEPTION_OCCURED 255</span>
<span style="font-style: italic">#define MAX_NO_PROCESSES 8</span>
<span style="font-style: italic">#define FIRST_GENERAL_USE_FD 2</span>
<span style="font-style: italic">#define NO_RESERVED_SYS_BIG_PAGES 2</span>
<span style="font-style: italic">#define FIRST_USER_PD_ENTRY_IDX 3</span>
<span style="font-style: italic">#define FILE_SIZE_BYTE_INDICATOR_NO 24</span>
<span style="font-style: italic">#define FILE_SIZE_INDICATOR_NO_BYTES 4</span>
<span style="font-style: italic">#define ERROR_PID 9999</span>
<span style="font-style: italic">#define PAGE_TABLE_MASK 0x003FF000</span>
<span style="font-style: italic">#define PAGE_DIRECTORY_MASK 0xFFC00000</span>
<span style="font-style: italic">#define PAGE_TABLE_SHIFT 12</span>
<span style="font-style: italic">#define PAGE_DIRECTORY_SHIFT 22</span>
<span style="font-style: italic">#define MEGABYTES_PER_PROGRAM_REGION 4</span>
<span style="font-style: italic">#define FILE_OP_TABLE_SIZE 4</span>
<span style="font-style: italic">#define FILE_OP_TABLE_IDX 3</span>
<span style="font-style: italic">#define FILE_OP_TABLE_IDX_WRITE 2</span>
<span style="font-style: italic">#define FILE_OP_TABLE_IDX_READ 1</span>
<span style="font-style: italic">#define ARGUMENTS_SIZE 128</span>
<span style="font-style: italic">#define MAX_NUMBER_FILES 8</span>
<span style="font-style: italic">#define SHELL_WORD_SIZE 6</span>
<span style="font-style: italic">#define LONG_SIZE 4</span>
<span style="font-style: italic">#define SIZEOF_FAKE_IRET_CONTEXT 16</span>
<span style="font-style: italic">#define MIN_FD 2</span>

<span style="font-weight: bold">typedef</span> int (*func)(<span style="font-weight: bold">void</span>);
<span style="font-weight: bold">typedef</span> int (*read)(<span style="font-weight: bold">uint32_t</span>, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>*, <span style="font-weight: bold">uint32_t</span>);
<span style="font-weight: bold">typedef</span> int (*write)(<span style="font-weight: bold">uint32_t</span>, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>*, <span style="font-weight: bold">uint32_t</span>);
<span style="font-weight: bold">typedef</span> int (*open)(<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>*);
<span style="font-weight: bold">typedef</span> int (*close)(<span style="font-weight: bold">int32_t</span>);

<span style="font-weight: bold">typedef</span> <span style="font-weight: bold">struct</span> <span style="font-weight: bold">file_descriptor_t</span> {
	func file_op_table [FILE_OP_TABLE_SIZE]; <span style="font-style: italic">//= {open, read, write, close};</span>
	<span style="font-weight: bold">uint32_t</span> inode;
	<span style="font-weight: bold">uint32_t</span> file_pos;
	<span style="font-weight: bold">uint32_t</span> flags; <span style="font-style: italic">// NOTE: flags might need to be initialized at start of process</span>
} <span style="font-weight: bold">file_descriptor_t</span>;

<span style="font-weight: bold">typedef</span> <span style="font-weight: bold">struct</span> program_control_block <span style="font-weight: bold">program_control_block_t</span>;
<span style="font-weight: bold">program_control_block_t</span> * terminal_pcb_stack [MAX_NUM_TERMINALS] [MAX_NO_PROCESSES];

<span style="font-weight: bold">struct</span> program_control_block {
	<span style="font-weight: bold">uint32_t</span> return_to_exec_addr; <span style="font-style: italic">// this has to be first field because of the way it is referenced iin some assembly code</span>
	<span style="font-weight: bold">uint32_t</span> esp; <span style="font-style: italic">//this has to be second field because it is referenced as 4 offset in the scheduler</span>
	<span style="font-weight: bold">uint32_t</span> ebp; <span style="font-style: italic">//this has to be third field because it...</span>
	<span style="font-weight: bold">uint8_t</span> has_pit_context; <span style="font-style: italic">//this has to be the fourth field because it...</span>
	<span style="font-weight: bold">file_descriptor_t</span> file_array[MAX_NUMBER_FILES]; <span style="font-style: italic">// file_array[0]/file_array[1] (stdin/stdout) need to be opeed whe process starts</span>
	<span style="font-weight: bold">program_control_block_t</span> * parent;
	<span style="font-weight: bold">uint32_t</span> * pg_dir_table;
	<span style="font-weight: bold">uint32_t</span> esp0;
	<span style="font-weight: bold">uint32_t</span> pid;
	<span style="font-weight: bold">uint32_t</span> starting_physical_addr_of_page; <span style="font-style: italic">//not a pointer, because this is a physical adress.</span>
	<span style="font-weight: bold">uint32_t</span> first_instruction_addr;
	<span style="font-weight: bold">uint8_t</span> halt_status;
	<span style="font-weight: bold">uint8_t</span> exception_encountered;
	<span style="font-weight: bold">uint8_t</span> arguments[ARGUMENTS_SIZE]; <span style="font-style: italic">// new addition</span>
	<span style="font-weight: bold">int</span> terminal_idx; <span style="font-style: italic">//idx in the terminals array specifying which terminal the process is associated with</span>
	<span style="font-weight: bold">uint8_t</span> vidmap_performed;
	<span style="font-weight: bold">uint32_t</span> cr3;
};

<span style="font-weight: bold">typedef</span> <span style="font-weight: bold">struct</span> {
		<span style="font-weight: bold">program_control_block_t</span> pcb;
		<span style="font-weight: bold">uint32_t</span> kernel_stack [KERNEL_STACK_LENGTH];
} <span style="font-weight: bold">process_struct_t</span> __attribute__((aligned(PROCESS_STRUCT_SIZE)));

<span style="font-weight: bold">uint32_t</span> available_pids [MAX_PROCESSES]; <span style="font-style: italic">//0 represents the pid equal to index is available, 1 taken</span>

<span style="font-weight: bold">int</span> execute_init_shell (<span style="font-weight: bold">int</span> associated_terminal);
<span style="font-weight: bold">int</span> system_execute (<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* command);
<span style="font-weight: bold">int</span> system_halt (<span style="font-weight: bold">uint8_t</span> status);
<span style="font-weight: bold">int</span> system_read(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes); <span style="font-style: italic">//MAY WANT TO ADD EXTERN HERE</span>
<span style="font-weight: bold">int</span> system_write(<span style="font-weight: bold">int32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">void</span>* buf, <span style="font-weight: bold">uint32_t</span> nbytes);
<span style="font-weight: bold">int</span> system_open(<span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span>* filename);
<span style="font-weight: bold">int</span> system_close(<span style="font-weight: bold">int32_t</span> fd);
<span style="font-weight: bold">int</span> system_getargs(<span style="font-weight: bold">uint8_t</span>* buf, <span style="font-weight: bold">int</span> nbytes);
<span style="font-weight: bold">int32_t</span> vidremap (<span style="font-weight: bold">program_control_block_t</span> * cur_pcb, <span style="font-weight: bold">uint32_t</span> remaped_here);

<span style="font-weight: bold">uint32_t</span> get_pcb_of_cur_process ();
<span style="font-weight: bold">int</span> get_pid_for_new_process (<span style="font-weight: bold">int</span> *err);

<span style="font-style: italic">#endif </span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--terminal.c-->
        <section>
            <hnew id="terminal.c">terminal.c</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#include &quot;terminal.h&quot;</span>

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:		switch_to_terminal</span>
<span style="font-style: italic"> * Description:		Switches the video display to show the terminal specified by the input, also switches the active keyboard buffer to redirect to the current terminal</span>
<span style="font-style: italic"> * Input:			new_terminal_idx: specifies the new terminal by idx</span>
<span style="font-style: italic"> * Output:			NONE</span>
<span style="font-style: italic"> * Side Effects:	Draws new terminal to VGA and stores the active terminal&#39;s VGA to video back pages</span>
<span style="font-style: italic"> * Return Value:	0 if success</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> switch_to_terminal (<span style="font-weight: bold">int</span> new_terminal_idx)
{
	<span style="font-weight: bold">int</span> i = 0;
	cli();
	<span style="font-weight: bold">int</span> old_terminal_idx = active_terminal-&gt;terminal_idx;

	<span style="font-weight: bold">if</span> (old_terminal_idx == new_terminal_idx)
			<span style="font-weight: bold">return</span> 0;
		
	<span style="font-weight: bold">for</span> (i = 0; i &lt; terminal_pcb_stack_tops [active_terminal-&gt;terminal_idx]; i++) {
			<span style="font-weight: bold">if</span> ((terminal_pcb_stack [active_terminal-&gt;terminal_idx][i])-&gt;vidmap_performed)
				vidremap (terminal_pcb_stack [active_terminal-&gt;terminal_idx][i], (<span style="font-weight: bold">uint32_t</span>) &amp;terminal_video_back_pages [active_terminal-&gt;terminal_idx * PAGE_SIZE_32b]);
	}
		
	<span style="font-weight: bold">for</span> (i = 0; i &lt; terminal_pcb_stack_tops [new_terminal_idx]; i++) {
			<span style="font-weight: bold">if</span> ((terminal_pcb_stack [new_terminal_idx][i])-&gt;vidmap_performed)
				vidremap (terminal_pcb_stack [new_terminal_idx][i], VIDEO_MEM_START_ADDR);
	}

	<span style="font-weight: bold">uint32_t</span> * mem_traverse;
	<span style="font-weight: bold">uint32_t</span> tmp; <span style="font-style: italic">//tmp variable to help with swapping</span>
	i = 0;
	<span style="font-weight: bold">for</span> (mem_traverse = (<span style="font-weight: bold">uint32_t</span> *) VIDEO_MEMORY_START_ADDR; mem_traverse &lt; (<span style="font-weight: bold">uint32_t</span> *) (VIDEO_MEMORY_START_ADDR + FOUR_KB); mem_traverse++) {
		tmp = *mem_traverse;
		*mem_traverse = terminal_video_back_pages[(i) + new_terminal_idx * PAGE_SIZE_32b];
		terminal_video_back_pages[(i++) + old_terminal_idx * PAGE_SIZE_32b] = tmp; <span style="font-style: italic">//copy the video memory of the terminal being switched out 32 bits at a time into its associated video memory back page</span>
	}
	
	active_terminal = &amp;terminals[new_terminal_idx];
	terminals[old_terminal_idx].video_memory_start = (<span style="font-weight: bold">uint8_t</span> *) &amp;terminal_video_back_pages [old_terminal_idx * PAGE_SIZE_32b];
	active_terminal-&gt;video_memory_start = (<span style="font-weight: bold">uint8_t</span> *) VIDEO_MEM_START_ADDR;

	sti();

	<span style="font-weight: bold">return</span> 0;
}




<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:		write_to_terminal</span>
<span style="font-style: italic"> * Description:		Writes the contents of the argument buffer into a new line on the terminal. Similar behavior to C library&#39;s printf.</span>
<span style="font-style: italic"> * Input:			fd: file descriptor</span>
<span style="font-style: italic"> *					buf: buffer that holds characters to be displayed later</span>
<span style="font-style: italic"> *					nbytes: number of bytes to be copied</span>
<span style="font-style: italic"> * Output:			NONE</span>
<span style="font-style: italic"> * Side Effects:	Draws contents of the buffer to the terminal and increments the cursor_x and cur_y positions asneeded.</span>
<span style="font-style: italic"> * Return Value:	0 if success</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">uint32_t</span> write_to_terminal (<span style="font-weight: bold">uint32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span> * buf, <span style="font-weight: bold">uint32_t</span> nbytes)
{
	cli (); <span style="font-style: italic">//entire OS assumes uniprocessor OS. Cli () is sufficient to ensure no interrupts. No further synchronization is necessary.</span>
	<span style="font-weight: bold">int</span> i;
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();

    <span style="font-weight: bold">terminal_t</span> * current_terminal = &amp;terminals[cur_pcb-&gt;terminal_idx];

	<span style="font-weight: bold">char</span> * video_memory = (<span style="font-weight: bold">char</span> *) terminals[cur_pcb-&gt;terminal_idx].video_memory_start; <span style="font-style: italic">//VIDEO_MEM_START_ADDR; // array to access video memory byte by byte</span>
	<span style="font-weight: bold">char</span> cur; <span style="font-style: italic">//current char temporary variable</span>

	<span style="font-weight: bold">for</span> (i = 0; i &lt; nbytes; i++) {
		cur = (<span style="font-weight: bold">char</span>) buf[i];
		video_memory[(current_terminal-&gt;cursor_x + current_terminal-&gt;cursor_y * VM_NUM_COLS) * BYTES_PER_VGA_SQUARE + 1] = BW_BACKG_FONT; <span style="font-style: italic">//set the attribute byte to specify appropriate background and font colors</span>
		<span style="font-weight: bold">if</span> (cur == <span style="font-style: italic">&#39;\n&#39;</span>) { <span style="font-style: italic">// process the newline character</span>
			<span style="font-weight: bold">for</span> (; current_terminal-&gt;cursor_x &lt; VM_NUM_COLS; current_terminal-&gt;cursor_x++)
					video_memory[(current_terminal-&gt;cursor_x + current_terminal-&gt;cursor_y * VM_NUM_COLS) * BYTES_PER_VGA_SQUARE] = <span style="font-style: italic">&#39; &#39;</span>; <span style="font-style: italic">//clear the line</span>

			current_terminal-&gt;cursor_x = 0; <span style="font-style: italic">//reset the x cursor</span>
			current_terminal-&gt;cursor_y++; <span style="font-style: italic">//next line</span>
			<span style="font-weight: bold">if</span> (current_terminal-&gt;cursor_y &gt;= VM_NUM_ROWS) {
				current_terminal-&gt;cursor_y = VM_NUM_ROWS - 1; <span style="font-style: italic">// keep cursor at end</span>
				scroll_vm ();
			}
		}
		<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (cur == <span style="font-style: italic">&#39;\0&#39;</span>) {
			<span style="font-weight: bold">for</span> (; current_terminal-&gt;cursor_x &lt; VM_NUM_COLS; current_terminal-&gt;cursor_x++)
				video_memory[(current_terminal-&gt;cursor_x + current_terminal-&gt;cursor_y * VM_NUM_COLS) * BYTES_PER_VGA_SQUARE] = <span style="font-style: italic">&#39; &#39;</span>; <span style="font-style: italic">//clear the line</span>
			current_terminal-&gt;cursor_x = 0; <span style="font-style: italic">//reset the x cursor</span>
			current_terminal-&gt;cursor_y++; <span style="font-style: italic">//next line</span>
			<span style="font-weight: bold">if</span> (current_terminal-&gt;cursor_y &gt;= VM_NUM_ROWS) {
				current_terminal-&gt;cursor_y = VM_NUM_ROWS - 1; <span style="font-style: italic">// keep cursor at end</span>
				scroll_vm ();
			}
			<span style="font-weight: bold">break</span>; <span style="font-style: italic">//NULL terminated string, string is done</span>
		}
		<span style="font-weight: bold">else</span> {
			video_memory[(current_terminal-&gt;cursor_x + current_terminal-&gt;cursor_y * VM_NUM_COLS) * BYTES_PER_VGA_SQUARE] = cur; <span style="font-style: italic">//write the current character to vga memory</span>
			current_terminal-&gt;cursor_x++;
			<span style="font-weight: bold">if</span>(current_terminal-&gt;cursor_x &gt;= VM_NUM_COLS) {
				current_terminal-&gt;cursor_x = 0; <span style="font-style: italic">//wrap around to next line</span>
				current_terminal-&gt;cursor_y++;
				<span style="font-weight: bold">if</span> (current_terminal-&gt;cursor_y &gt;= VM_NUM_ROWS) { <span style="font-style: italic">//wrap around to the begining if necessary</span>
					current_terminal-&gt;cursor_y = VM_NUM_ROWS - 1; <span style="font-style: italic">// keep cursor at end</span>
					scroll_vm ();
				}
			}
		}

	}

	update_cursor(current_terminal-&gt;cursor_x, current_terminal-&gt;cursor_y);

	sti ();
	<span style="font-weight: bold">return</span> 0;
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:		get_keyboard_buffer_length</span>
<span style="font-style: italic"> * Description:		Getter function returns length of keyboard buffer by computing distance between head and tail</span>
<span style="font-style: italic"> * Input:			NONE</span>
<span style="font-style: italic"> * Output:			length of the keyboard buffer</span>
<span style="font-style: italic"> * Return Value:	NONE</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">int</span> get_keyboard_buffer_length () 
{
	<span style="font-weight: bold">int</span> keyboard_buf_length; 

	<span style="font-weight: bold">if</span> (active_terminal-&gt;keyboard_buf_idx_tail &gt; active_terminal-&gt;keyboard_buf_idx_head)
 		keyboard_buf_length = (active_terminal-&gt;keyboard_buf_idx_tail - active_terminal-&gt;keyboard_buf_idx_head);
 	<span style="font-weight: bold">else</span> <span style="font-weight: bold">if</span> (active_terminal-&gt;keyboard_buf_idx_tail == active_terminal-&gt;keyboard_buf_idx_head)
 		keyboard_buf_length = 0;
 	<span style="font-weight: bold">else</span>
 		keyboard_buf_length = KEYBOARD_BUF_SIZE - (active_terminal-&gt;keyboard_buf_idx_head - active_terminal-&gt;keyboard_buf_idx_tail);

 	<span style="font-weight: bold">return</span> keyboard_buf_length;
}
<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:		draw_terminal_to_vga</span>
<span style="font-style: italic"> * Description:		copies characters to video memory</span>
<span style="font-style: italic"> * Input:			NONE</span>
<span style="font-style: italic"> * Output:			characters on screen	</span>
<span style="font-style: italic"> * Return Value:	NONE</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> draw_terminal_to_vga () 
{
	<span style="font-weight: bold">char</span> * video_memory = (<span style="font-weight: bold">char</span> *) active_terminal-&gt;video_memory_start; <span style="font-style: italic">// (char *) VIDEO_MEM_START_ADDR;</span>

	<span style="font-weight: bold">int</span> vm_offset = (active_terminal-&gt;cursor_x % VM_NUM_COLS + active_terminal-&gt;cursor_y * VM_NUM_COLS) * BYTES_PER_VGA_SQUARE;

	<span style="font-weight: bold">int</span> i;
	<span style="font-weight: bold">int</span> keyboard_buf_length; 
	<span style="font-weight: bold">char</span> cur;
	<span style="font-weight: bold">uint8_t</span> permission_to_scroll; <span style="font-style: italic">//flag to allow scrolling once for buffer overflow at end of the terminal</span>

	keyboard_buf_length = get_keyboard_buffer_length ();

	<span style="font-weight: bold">if</span> (active_terminal-&gt;cursor_y == VM_NUM_ROWS - 1) <span style="font-style: italic">//if the adjustment has pushed off screen</span>
		permission_to_scroll = 0x01;
	<span style="font-weight: bold">else</span>
		permission_to_scroll = 0x00;


	<span style="font-weight: bold">for</span> (i = 0; i &lt; keyboard_buf_length; i++) {
		<span style="font-weight: bold">if</span> (i &gt;= VM_NUM_COLS &amp;&amp; permission_to_scroll) {
			scroll_vm();
			vm_offset = (--active_terminal-&gt;cursor_y) * VM_NUM_COLS * BYTES_PER_VGA_SQUARE; <span style="font-style: italic">// should appear to rest of function as if cursor_y was always at the second to last line</span>
			permission_to_scroll = 0x00;
		}
		cur = (<span style="font-weight: bold">char</span>) active_terminal-&gt;keyboard_buffer[(active_terminal-&gt;keyboard_buf_idx_head + i) % KEYBOARD_BUF_SIZE];
		video_memory[vm_offset + BYTES_PER_VGA_SQUARE*i + 1] = BW_BACKG_FONT;
		<span style="font-weight: bold">if</span> (cur != <span style="font-style: italic">&#39;\n&#39;</span>)
			video_memory[vm_offset + BYTES_PER_VGA_SQUARE*i] = cur;
		<span style="font-weight: bold">else</span>
			video_memory[vm_offset + BYTES_PER_VGA_SQUARE*i] = <span style="font-style: italic">&#39; &#39;</span>;
	}

	<span style="font-weight: bold">for</span> (; (i == 0) || i % VM_NUM_COLS != 0 ; i++) {
		video_memory[vm_offset + BYTES_PER_VGA_SQUARE*i + 1] = BW_BACKG_FONT;
		video_memory[vm_offset + BYTES_PER_VGA_SQUARE*i] = <span style="font-style: italic">&#39; &#39;</span>;
	}
		
}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:		clear_terminal</span>
<span style="font-style: italic"> * Description:		clears screen by changing video memory data</span>
<span style="font-style: italic"> * Input:			NONE</span>
<span style="font-style: italic"> * Output:			cleared screen</span>
<span style="font-style: italic"> * Return Value:	NONE</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> clear_terminal ()
{
	active_terminal-&gt;cursor_x = 0;
	active_terminal-&gt;cursor_y = 0;

	<span style="font-weight: bold">char</span> * video_memory = (<span style="font-weight: bold">char</span> *) VIDEO_MEM_START_ADDR;
	<span style="font-weight: bold">int</span> i;

	<span style="font-weight: bold">for</span> (i = 0; i &lt; VM_NUM_COLS * VM_NUM_ROWS * BYTES_PER_VGA_SQUARE ; i += BYTES_PER_VGA_SQUARE) {
			video_memory[i+1] = CLEAR_BACKG_FONT;
			video_memory[i] = <span style="font-style: italic">&#39; &#39;</span>;
		}


}

<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function:		scroll_vm</span>
<span style="font-style: italic"> * Description:		scrolls the video memory up by one row</span>
<span style="font-style: italic"> * Input:			NONE</span>
<span style="font-style: italic"> * Output:			scrolled video memory.</span>
<span style="font-style: italic"> * Return Value:	NONE</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> scroll_vm ()
{
	<span style="font-weight: bold">program_control_block_t</span> * cur_pcb = (<span style="font-weight: bold">program_control_block_t</span> *) get_pcb_of_cur_process();

    <span style="font-weight: bold">terminal_t</span> * current_terminal = &amp;terminals[cur_pcb-&gt;terminal_idx];

	<span style="font-weight: bold">char</span> * video_memory = (<span style="font-weight: bold">char</span> *) current_terminal-&gt;video_memory_start;
	<span style="font-weight: bold">int</span> i, j;

	<span style="font-weight: bold">for</span> (j = 0; j &lt; VM_NUM_ROWS - 1; j ++) {
		<span style="font-weight: bold">for</span> (i = 0; i &lt; VM_NUM_COLS; i ++) {
			video_memory[(j * VM_NUM_COLS * BYTES_PER_VGA_SQUARE) + i * BYTES_PER_VGA_SQUARE + 1] = video_memory[(j * VM_NUM_COLS * BYTES_PER_VGA_SQUARE) + i * BYTES_PER_VGA_SQUARE + 1 + BYTES_PER_VGA_SQUARE * VM_NUM_COLS];
			video_memory[(j * VM_NUM_COLS * BYTES_PER_VGA_SQUARE) + i * BYTES_PER_VGA_SQUARE] = video_memory[(j * VM_NUM_COLS * BYTES_PER_VGA_SQUARE) + i * BYTES_PER_VGA_SQUARE + BYTES_PER_VGA_SQUARE * VM_NUM_COLS];
		}
	}

	<span style="font-weight: bold">for</span> (i = 0; i &lt; VM_NUM_COLS; i++)
		video_memory[(i + (VM_NUM_ROWS - 1) * VM_NUM_COLS) * BYTES_PER_VGA_SQUARE] = <span style="font-style: italic">&#39; &#39;</span>; <span style="font-style: italic">//clear the line</span>
}



<span style="font-style: italic">/*</span>
<span style="font-style: italic"> * Function: 		update_cursor</span>
<span style="font-style: italic"> * Description:		updates the cursor as we are typing	</span>
<span style="font-style: italic"> * Input:			cursor_x : the x position (col number) at which we are</span>
<span style="font-style: italic"> *					cursor_y : the y position (row number) at which we are</span>
<span style="font-style: italic"> * Output:			cursor at the (x,y) position</span>
<span style="font-style: italic"> * Return Value:	NONE</span>
<span style="font-style: italic"> */</span>
<span style="font-weight: bold">void</span> update_cursor(<span style="font-weight: bold">uint32_t</span> cursor_x, <span style="font-weight: bold">uint32_t</span> cursor_y)
{
	<span style="font-weight: bold">uint16_t</span> position = cursor_x + (cursor_y * VM_NUM_COLS);

	<span style="font-style: italic">//low port: lower 8 bits of &quot;position&quot; </span>
	<span style="font-style: italic">//address port: 0x3D4, data port: 0x3D5</span>
	<span style="font-style: italic">//reg to access for low port: 0x0F</span>
	outb(LOW_PORT_REG, ADDRESS_PORT);
	outb((<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">char</span>)(position &amp; BIT_MASK), DATA_PORT);

	<span style="font-style: italic">//same for high port after shifting &quot;position&quot; 8 bits to the right (bits 15 to 8)</span>
	<span style="font-style: italic">//reg to access for high port: 0x0E</span>
	outb(HIGH_PORT_REG, ADDRESS_PORT);
	outb((<span style="font-weight: bold">unsigned</span> <span style="font-weight: bold">char</span>)((position &gt;&gt; BIT_SHIFT) &amp; BIT_MASK), DATA_PORT);
}<span style="font-style: italic">//end update_cursor</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--terminal.h-->
        <section>
            <hnew id="terminal.h">terminal.h</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic">#ifndef _TERMINAL_H</span>
<span style="font-style: italic">#define _TERMINAL_H</span>

<span style="font-style: italic">#include &quot;lib.h&quot;</span>
<span style="font-style: italic">#include &quot;system_calls.h&quot;</span>


<span style="font-style: italic">#define KEYBOARD_BUF_SIZE 128</span>
<span style="font-style: italic">#define VIDEO_MEM_START_ADDR 0xB8000</span>
<span style="font-style: italic">#define VM_NUM_COLS 80</span>
<span style="font-style: italic">#define VM_NUM_ROWS 25</span>
<span style="font-style: italic">#define BW_BACKG_FONT		0x03</span>
<span style="font-style: italic">#define CLEAR_BACKG_FONT	0x03</span>
<span style="font-style: italic">#define MAX_NUM_TERMINALS 3</span>
<span style="font-style: italic">#define MAX_NO_PROCESSES 8</span>

<span style="font-style: italic">#define ADDRESS_PORT 0x3D4</span>
<span style="font-style: italic">#define DATA_PORT 0x3D5</span>
<span style="font-style: italic">#define LOW_PORT_REG 0x0F</span>
<span style="font-style: italic">#define HIGH_PORT_REG 0x0E</span>
<span style="font-style: italic">#define BIT_MASK 0xFF</span>
<span style="font-style: italic">#define BIT_SHIFT 8</span>
 <span style="border: 1px solid #FF0000">#</span>define BYTES_PER_VGA_SQUARE 2

<span style="font-weight: bold">typedef</span> <span style="font-weight: bold">struct</span> terminal {
		<span style="font-weight: bold">uint8_t</span> keyboard_buffer [KEYBOARD_BUF_SIZE];
		<span style="font-weight: bold">int</span> keyboard_buf_idx_head;
		<span style="font-weight: bold">int</span> keyboard_buf_idx_tail;
		<span style="font-weight: bold">int</span> buffer_went_onto_two_lines;
		<span style="font-weight: bold">uint8_t</span> terminal_out_empty_flag;
		<span style="font-weight: bold">uint8_t</span> terminal_out_released_flag; <span style="font-style: italic">// flag to indicate that &#39;enter&#39; key has been pressed and buffer can be emptied</span>
		<span style="font-weight: bold">uint32_t</span> cursor_x; <span style="font-style: italic">//x coord in video memory that current cursor is located at</span>
		<span style="font-weight: bold">uint32_t</span> cursor_y; <span style="font-style: italic">//y coord in video memory that current cursor is located at</span>
		<span style="font-weight: bold">int</span> init_shell_pid;
		<span style="font-weight: bold">uint8_t</span> * video_memory_start;
		<span style="font-weight: bold">int</span> terminal_idx;
} <span style="font-weight: bold">terminal_t</span>;


<span style="font-weight: bold">terminal_t</span> terminals [MAX_NUM_TERMINALS]; <span style="font-style: italic">//create a data structure that associates each terminal with a stack of associated pcbs</span>
<span style="font-weight: bold">terminal_t</span> * active_terminal; <span style="font-style: italic">//pointer to the active terminal</span>


<span style="font-weight: bold">int</span> terminal_pcb_stack_tops [MAX_NUM_TERMINALS]; <span style="font-style: italic">//pointer to the top of each stack</span>

<span style="font-weight: bold">void</span> update_cursor(<span style="font-weight: bold">uint32_t</span> cursor_x, <span style="font-weight: bold">uint32_t</span> cursor_y);
<span style="font-weight: bold">int</span> switch_to_terminal (<span style="font-weight: bold">int</span> new_terminal_idx);

<span style="font-weight: bold">extern</span> <span style="font-weight: bold">uint32_t</span> write_to_terminal (<span style="font-weight: bold">uint32_t</span> fd, <span style="font-weight: bold">const</span> <span style="font-weight: bold">uint8_t</span> * buf, <span style="font-weight: bold">uint32_t</span> nbytes);
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> clear_terminal();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> draw_terminal_to_vga();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">void</span> scroll_vm ();
<span style="font-weight: bold">extern</span> <span style="font-weight: bold">int</span> get_keyboard_buffer_length ();

<span style="font-style: italic">#endif</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        <!--Makefile-->
        <section>
            <hnew id="Makefile">Makefile</hnew><br>
            <a href="#" class="buttonBackToTop">BACK TO TOP</a>
            
            <!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="font-style: italic"># Makefile for OS project</span>
<span style="font-style: italic"># To build, first `make dep`, them `make`. Everything should be automatic.</span>
<span style="font-style: italic"># Will compile all *.c and *.S files in the current directory.</span>


<span style="font-style: italic"># Flags to use when compiling, preprocessing, assembling, and linking</span>
CFLAGS+=-Wall -fno-builtin -fno-stack-protector -nostdlib
ASFLAGS+=
LDFLAGS+=-nostdlib -static
CC=gcc

<span style="font-style: italic">#If you have any .h files in another directory, add -I&lt;dir&gt; to this line</span>
CPPFLAGS+=-nostdinc -g

<span style="font-style: italic"># This generates the list of source files</span>
SRC=<span style="font-weight: bold">$(</span>wildcard *.S<span style="font-weight: bold">)</span> <span style="font-weight: bold">$(</span>wildcard *.c<span style="font-weight: bold">)</span> <span style="font-weight: bold">$(</span>wildcard */*.S<span style="font-weight: bold">)</span> <span style="font-weight: bold">$(</span>wildcard */*.c<span style="font-weight: bold">)</span>

<span style="font-style: italic"># This generates the list of .o files. The order matters, boot.o must be first</span>
OBJS=boot.o
OBJS+=<span style="font-weight: bold">$(</span>filter-out boot.o,<span style="font-weight: bold">$(</span>patsubst %.S,%.o,<span style="font-weight: bold">$(</span>filter %.S,<span style="font-weight: bold">$(</span>SRC<span style="font-weight: bold">))))</span>
OBJS+=<span style="font-weight: bold">$(</span>patsubst %.c,%.o,<span style="font-weight: bold">$(</span>filter %.c,<span style="font-weight: bold">$(</span>SRC<span style="font-weight: bold">)))</span>

bootimg: Makefile $(OBJS)
	rm -f bootimg
	<span style="font-weight: bold">$(</span>CC<span style="font-weight: bold">)</span> <span style="font-weight: bold">$(</span>LDFLAGS<span style="font-weight: bold">)</span> <span style="font-weight: bold">$(</span>OBJS<span style="font-weight: bold">)</span> -Ttext=0x400000 -o bootimg
	sudo ./debug.sh

dep: Makefile.dep

Makefile.dep: $(SRC)
	<span style="font-weight: bold">$(</span>CC<span style="font-weight: bold">)</span> -MM <span style="font-weight: bold">$(</span>CPPFLAGS<span style="font-weight: bold">)</span> <span style="font-weight: bold">$(</span>SRC<span style="font-weight: bold">)</span> &gt; $@

.PHONY: clean
clean:
	rm -f *.o */*.o Makefile.dep

<span style="font-style: italic">ifneq ($(MAKECMDGOALS),dep)</span>
<span style="font-style: italic">ifneq ($(MAKECMDGOALS),clean)</span>
<span style="font-style: italic">include Makefile.dep</span>
<span style="font-style: italic">endif</span>
<span style="font-style: italic">endif</span>
</pre></div>
<p></p>
            
        </section>
        
        
        
        
        _____________________________________________________________________________________________________________________________________________________________
        <br>
        <br>
        
        
         <!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrollgress.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.slidertron.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>
        
        
        <!--Back to top-->
        <section id="cta" class="wrapper style3">
				
				<ul class="actions">
					<li><a href="#" class="button big">Back to Top</a></li>
				</ul>
            
            
                <ul class="actions">
					<li><a href="index.html" class="button big">Main Menu</a></li>
				</ul>
			</section> 
        
        <footer id="footer">
				<ul class="icons">
					
					
					
					<li><a href="https://www.linkedin.com/in/lisa-gentil-33b45892/" class="icon fa-linkedin"><span class="label">LinkedIn</span></a></li>
					<li><a href="mailto:gentillisa5@gmail.com" class="icon fa-envelope"><span class="label">Envelope</span></a></li>
				</ul>
				
				<span>
				Lisa Gentil's Portfolio
				</span>
			</footer>
    </body>
</html>